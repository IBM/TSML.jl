<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types and Functions · TSML Documentation</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TSML Documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">HOME</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../../tutorial/aggregators/">Aggregators and Imputers</a></li><li><a class="tocitem" href="../../tutorial/pipeline/">Pipeline</a></li><li><a class="tocitem" href="../../tutorial/statistics/">Statistical Metrics</a></li><li><a class="tocitem" href="../../tutorial/monotonic_plotting/">Monotonic Detection and Plotting</a></li><li><a class="tocitem" href="../../tutorial/tsclassifier/">TS Data Discovery</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/valueproc/">Value PreProcessing</a></li><li><a class="tocitem" href="../../man/dateproc/">Date PreProcessing</a></li><li><a class="tocitem" href="../../man/aggregation/">Aggregation</a></li><li><a class="tocitem" href="../../man/imputation/">Imputation</a></li></ul></li><li><span class="tocitem">ML Library</span><ul><li class="is-active"><a class="tocitem" href>Types and Functions</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Descriptions"><span>Descriptions</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ML Library</a></li><li class="is-active"><a href>Types and Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types and Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/IBM/TSML.jl/blob/master/docs/src/lib/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="lib_decisiontree"><a class="docs-heading-anchor" href="#lib_decisiontree">Types and Functions</a><a id="lib_decisiontree-1"></a><a class="docs-heading-anchor-permalink" href="#lib_decisiontree" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#AMLPipelineBase.BaseFilters.Imputer"><code>AMLPipelineBase.BaseFilters.Imputer</code></a></li><li><a href="#AMLPipelineBase.BaseFilters.OneHotEncoder"><code>AMLPipelineBase.BaseFilters.OneHotEncoder</code></a></li><li><a href="#AMLPipelineBase.BaseFilters.Wrapper"><code>AMLPipelineBase.BaseFilters.Wrapper</code></a></li><li><a href="#AMLPipelineBase.BaseFilters.createtransformer"><code>AMLPipelineBase.BaseFilters.createtransformer</code></a></li><li><a href="#AMLPipelineBase.BaselineModels.Baseline"><code>AMLPipelineBase.BaselineModels.Baseline</code></a></li><li><a href="#AMLPipelineBase.BaselineModels.Baseline-Tuple{String}"><code>AMLPipelineBase.BaselineModels.Baseline</code></a></li><li><a href="#AMLPipelineBase.BaselineModels.Identity-Tuple{String}"><code>AMLPipelineBase.BaselineModels.Identity</code></a></li><li><a href="#AMLPipelineBase.BaselineModels.Identity"><code>AMLPipelineBase.BaselineModels.Identity</code></a></li><li><a href="#AMLPipelineBase.CrossValidators.crossvalidate-Tuple{Machine, DataFrame, Vector, Function, Int64, Bool}"><code>AMLPipelineBase.CrossValidators.crossvalidate</code></a></li><li><a href="#AMLPipelineBase.DecisionTreeLearners.Adaboost"><code>AMLPipelineBase.DecisionTreeLearners.Adaboost</code></a></li><li><a href="#AMLPipelineBase.DecisionTreeLearners.PrunedTree"><code>AMLPipelineBase.DecisionTreeLearners.PrunedTree</code></a></li><li><a href="#AMLPipelineBase.DecisionTreeLearners.RandomForest"><code>AMLPipelineBase.DecisionTreeLearners.RandomForest</code></a></li><li><a href="#AMLPipelineBase.EnsembleMethods.BestLearner"><code>AMLPipelineBase.EnsembleMethods.BestLearner</code></a></li><li><a href="#AMLPipelineBase.EnsembleMethods.StackEnsemble"><code>AMLPipelineBase.EnsembleMethods.StackEnsemble</code></a></li><li><a href="#AMLPipelineBase.EnsembleMethods.VoteEnsemble"><code>AMLPipelineBase.EnsembleMethods.VoteEnsemble</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.CatFeatureSelector"><code>AMLPipelineBase.FeatureSelectors.CatFeatureSelector</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.CatNumDiscriminator-Tuple{Int64}"><code>AMLPipelineBase.FeatureSelectors.CatNumDiscriminator</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.CatNumDiscriminator"><code>AMLPipelineBase.FeatureSelectors.CatNumDiscriminator</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.FeatureSelector"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Vector{Int64}}"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Vararg{Int64}}"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.NumFeatureSelector"><code>AMLPipelineBase.FeatureSelectors.NumFeatureSelector</code></a></li><li><a href="#TSML.MLBaseWrapper.StandardScaler"><code>TSML.MLBaseWrapper.StandardScaler</code></a></li><li><a href="#TSML.MLBaseWrapper.Standardize"><code>TSML.MLBaseWrapper.Standardize</code></a></li><li><a href="#TSML.Monotonicers.Monotonicer"><code>TSML.Monotonicers.Monotonicer</code></a></li><li><a href="#TSML.Normalizers.Normalizer"><code>TSML.Normalizers.Normalizer</code></a></li><li><a href="#TSML.Outliernicers.Outliernicer"><code>TSML.Outliernicers.Outliernicer</code></a></li><li><a href="#AMLPipelineBase.Pipelines.ComboPipeline"><code>AMLPipelineBase.Pipelines.ComboPipeline</code></a></li><li><a href="#AMLPipelineBase.Pipelines.Pipeline"><code>AMLPipelineBase.Pipelines.Pipeline</code></a></li><li><a href="#AMLPipelineBase.Pipelines.Pipeline-Tuple{Vector{&lt;:Machine}, Dict}"><code>AMLPipelineBase.Pipelines.Pipeline</code></a></li><li><a href="#AMLPipelineBase.Pipelines.Pipeline-Tuple{Vararg{Machine}}"><code>AMLPipelineBase.Pipelines.Pipeline</code></a></li><li><a href="#TSML.Plotters.Plotter"><code>TSML.Plotters.Plotter</code></a></li><li><a href="#TSML.Statifiers.Statifier"><code>TSML.Statifiers.Statifier</code></a></li><li><a href="#TSML.TSClassifiers.TSClassifier"><code>TSML.TSClassifiers.TSClassifier</code></a></li><li><a href="#TSML.ValDateFilters.CSVDateValReader"><code>TSML.ValDateFilters.CSVDateValReader</code></a></li><li><a href="#TSML.ValDateFilters.CSVDateValWriter"><code>TSML.ValDateFilters.CSVDateValWriter</code></a></li><li><a href="#TSML.ValDateFilters.DateValLinearImputer"><code>TSML.ValDateFilters.DateValLinearImputer</code></a></li><li><a href="#TSML.ValDateFilters.DateValMultiNNer"><code>TSML.ValDateFilters.DateValMultiNNer</code></a></li><li><a href="#TSML.ValDateFilters.DateValNNer"><code>TSML.ValDateFilters.DateValNNer</code></a></li><li><a href="#TSML.ValDateFilters.DateValgator"><code>TSML.ValDateFilters.DateValgator</code></a></li><li><a href="#TSML.ValDateFilters.DateValizer"><code>TSML.ValDateFilters.DateValizer</code></a></li><li><a href="#TSML.ValDateFilters.Dateifier"><code>TSML.ValDateFilters.Dateifier</code></a></li><li><a href="#TSML.ValDateFilters.Matrifier"><code>TSML.ValDateFilters.Matrifier</code></a></li></ul><h2 id="Descriptions"><a class="docs-heading-anchor" href="#Descriptions">Descriptions</a><a id="Descriptions-1"></a><a class="docs-heading-anchor-permalink" href="#Descriptions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaseFilters.Imputer" href="#AMLPipelineBase.BaseFilters.Imputer"><code>AMLPipelineBase.BaseFilters.Imputer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Imputer(
   Dict(
      # Imputation strategy.
      # Statistic that takes a vector such as mean or median.
      :strategy =&gt; mean
   )
)</code></pre><p>Imputes NaN values from Float64 features.</p><p>Implements <code>fit!</code> and <code>transform</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaseFilters.OneHotEncoder" href="#AMLPipelineBase.BaseFilters.OneHotEncoder"><code>AMLPipelineBase.BaseFilters.OneHotEncoder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OneHotEncoder(Dict(
   # Nominal columns
   :nominal_columns =&gt; Int[],

   # Nominal column values map. Key is column index, value is list of
   # possible values for that column.
   :nominal_column_values_map =&gt; Dict{Int,Any}()
))</code></pre><p>Transforms myinstances with nominal features into one-hot form and coerces the instance matrix to be of element type Float64.</p><p>Implements <code>fit!</code> and <code>transform</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaseFilters.Wrapper" href="#AMLPipelineBase.BaseFilters.Wrapper"><code>AMLPipelineBase.BaseFilters.Wrapper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Wrapper(
   default_args = Dict(
      :name =&gt; &quot;ohe-wrapper&quot;,
      # Transformer to call.
      :transformer =&gt; OneHotEncoder(),
      # Transformer args.
      :transformer_args =&gt; Dict()
   )
)</code></pre><p>Wraps around a transformer.</p><p>Implements <code>fit!</code> and <code>transform</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaseFilters.createtransformer" href="#AMLPipelineBase.BaseFilters.createtransformer"><code>AMLPipelineBase.BaseFilters.createtransformer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">createtransformer(prototype::Transformer, args=Dict())</code></pre><p>Create transformer</p><ul><li><code>prototype</code>: prototype transformer to base new transformer on</li><li><code>options</code>: additional options to override prototype&#39;s options</li></ul><p>Returns: new transformer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaselineModels.Baseline" href="#AMLPipelineBase.BaselineModels.Baseline"><code>AMLPipelineBase.BaselineModels.Baseline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Baseline(
   default_args = Dict(
       :name =&gt; &quot;baseline&quot;,
      :output =&gt; :class,
      :strat =&gt; mode
   )
)</code></pre><p>Baseline model that returns the mode during classification.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaselineModels.Baseline-Tuple{String}" href="#AMLPipelineBase.BaselineModels.Baseline-Tuple{String}"><code>AMLPipelineBase.BaselineModels.Baseline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Baseline(name::String,opt...)</code></pre><p>Helper function</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaselineModels.Identity" href="#AMLPipelineBase.BaselineModels.Identity"><code>AMLPipelineBase.BaselineModels.Identity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Identity(args=Dict())</code></pre><p>Returns the input as output.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaselineModels.Identity-Tuple{String}" href="#AMLPipelineBase.BaselineModels.Identity-Tuple{String}"><code>AMLPipelineBase.BaselineModels.Identity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Identity(name::String,opt...)</code></pre><p>Helper function</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(idy::Identity,x::DataFrame,y::Vector)</code></pre><p>Does nothing.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{Baseline, DataFrame, Vector}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{Baseline, DataFrame, Vector}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(bsl::Baseline,x::DataFrame,y::Vector)</code></pre><p>Get the mode of the training data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!" href="#AMLPipelineBase.AbsTypes.transform!"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform!(idy::Identity,x::DataFrame)</code></pre><p>Return the input as output.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Baseline, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Baseline, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(bsl::Baseline,x::DataFrame)</code></pre><p>Return the mode in classification.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.CrossValidators.crossvalidate-Tuple{Machine, DataFrame, Vector, Function, Int64, Bool}" href="#AMLPipelineBase.CrossValidators.crossvalidate-Tuple{Machine, DataFrame, Vector, Function, Int64, Bool}"><code>AMLPipelineBase.CrossValidators.crossvalidate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">crossvalidate(pl::Machine,X::DataFrame,Y::Vector,pfunc::Function,kfolds=10)</code></pre><p>Run K-fold crossvalidation where:</p><ul><li><code>pfunc</code> is a performance metric</li><li><code>X</code> and <code>Y</code> are input and target </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.DecisionTreeLearners.Adaboost" href="#AMLPipelineBase.DecisionTreeLearners.Adaboost"><code>AMLPipelineBase.DecisionTreeLearners.Adaboost</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Adaboost(
  Dict(
    :output =&gt; :class,
    :num_iterations =&gt; 7
  )
)</code></pre><p>Adaboosted decision tree stumps. See <a href="https://github.com/bensadeghi/DecisionTree.jl">DecisionTree.jl&#39;s documentation</a></p><p>Hyperparameters:</p><ul><li><code>:num_iterations</code> =&gt; 7 (number of iterations of AdaBoost)</li></ul><p>Implements <code>fit!</code>, <code>transform!</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.DecisionTreeLearners.PrunedTree" href="#AMLPipelineBase.DecisionTreeLearners.PrunedTree"><code>AMLPipelineBase.DecisionTreeLearners.PrunedTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrunedTree(
  Dict(
    :purity_threshold =&gt; 1.0,
    :max_depth =&gt; -1,
    :min_samples_leaf =&gt; 1,
    :min_samples_split =&gt; 2,
    :min_purity_increase =&gt; 0.0
  )
)</code></pre><p>Decision tree classifier.   See <a href="https://github.com/bensadeghi/DecisionTree.jl">DecisionTree.jl&#39;s documentation</a></p><p>Hyperparmeters:</p><ul><li><code>:purity_threshold</code> =&gt; 1.0 (merge leaves having &gt;=thresh combined purity)</li><li><code>:max_depth</code> =&gt; -1 (maximum depth of the decision tree)</li><li><code>:min_samples_leaf</code> =&gt; 1 (the minimum number of samples each leaf needs to have)</li><li><code>:min_samples_split</code> =&gt; 2 (the minimum number of samples in needed for a split)</li><li><code>:min_purity_increase</code> =&gt; 0.0 (minimum purity needed for a split)</li></ul><p>Implements <code>fit!</code>, <code>transform!</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.DecisionTreeLearners.RandomForest" href="#AMLPipelineBase.DecisionTreeLearners.RandomForest"><code>AMLPipelineBase.DecisionTreeLearners.RandomForest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomForest(
  Dict(
    :output =&gt; :class,
    :num_subfeatures =&gt; 0,
    :num_trees =&gt; 10,
    :partial_sampling =&gt; 0.7,
    :max_depth =&gt; -1
  )
)</code></pre><p>Random forest classification.  See <a href="https://github.com/bensadeghi/DecisionTree.jl">DecisionTree.jl&#39;s documentation</a></p><p>Hyperparmeters:</p><ul><li><code>:num_subfeatures</code> =&gt; 0  (number of features to consider at random per split)</li><li><code>:num_trees</code> =&gt; 10 (number of trees to train)</li><li><code>:partial_sampling</code> =&gt; 0.7 (fraction of samples to train each tree on)</li><li><code>:max_depth</code> =&gt; -1 (maximum depth of the decision trees)</li><li><code>:min_samples_leaf</code> =&gt; 1 (the minimum number of samples each leaf needs to have)</li><li><code>:min_samples_split</code> =&gt; 2 (the minimum number of samples in needed for a split)</li><li><code>:min_purity_increase</code> =&gt; 0.0 (minimum purity needed for a split)</li></ul><p>Implements <code>fit!</code>, <code>transform!</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{Adaboost, DataFrame, Vector}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{Adaboost, DataFrame, Vector}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(adaboost::Adaboost, features::DataFrame, labels::Vector)</code></pre><p>Optimize the hyperparameters of <code>Adaboost</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{PrunedTree, DataFrame, Vector}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{PrunedTree, DataFrame, Vector}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(tree::PrunedTree, features::DataFrame, labels::Vector)</code></pre><p>Optimize the hyperparameters of <code>PrunedTree</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{RandomForest, DataFrame, Vector}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{RandomForest, DataFrame, Vector}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(forest::RandomForest, features::DataFrame, labels::Vector)</code></pre><p>Optimize the parameters of the <code>RandomForest</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Adaboost, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Adaboost, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(adaboost::Adaboost, features::DataFrame)</code></pre><p>Predict using the optimized hyperparameters of the trained <code>Adaboost</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{PrunedTree, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{PrunedTree, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(ptree::PrunedTree, features::DataFrame)</code></pre><p>Predict using the optimized hyperparameters of the trained <code>PrunedTree</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{RandomForest, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{RandomForest, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(forest::RandomForest, features::DataFrame)</code></pre><p>Predict using the optimized hyperparameters of the trained <code>RandomForest</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.EnsembleMethods.BestLearner" href="#AMLPipelineBase.EnsembleMethods.BestLearner"><code>AMLPipelineBase.EnsembleMethods.BestLearner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BestLearner(
   Dict(
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Function to return partitions of instance indices.
      :partition_generator =&gt; (instances, labels) -&gt; kfold(size(instances, 1), 5),
      # Function that selects the best learner by index.
      # Arg learner_partition_scores is a (learner, partition) score matrix.
      :selection_function =&gt; (learner_partition_scores) -&gt; findmax(mean(learner_partition_scores, dims=2))[2],      
      # Score type returned by score() using respective output.
      :score_type =&gt; Real,
      # Candidate learners.
      :learners =&gt; [PrunedTree(), Adaboost(), RandomForest()],
      # Options grid for learners, to search through by BestLearner.
      # Format is [learner_1_options, learner_2_options, ...]
      # where learner_options is same as a learner&#39;s options but
      # with a list of values instead of scalar.
      :learner_options_grid =&gt; nothing
   )
)</code></pre><p>Selects best learner from the set by performing a  grid search on learners if grid option is indicated.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.EnsembleMethods.StackEnsemble" href="#AMLPipelineBase.EnsembleMethods.StackEnsemble"><code>AMLPipelineBase.EnsembleMethods.StackEnsemble</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StackEnsemble(
   Dict(    
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Set of learners that produce feature space for stacker.
      :learners =&gt; [PrunedTree(), Adaboost(), RandomForest()],
      # Machine learner that trains on set of learners&#39; outputs.
      :stacker =&gt; RandomForest(),
      # Proportion of training set left to train stacker itself.
      :stacker_training_proportion =&gt; 0.3,
      # Provide original features on top of learner outputs to stacker.
      :keep_original_features =&gt; false
   )
)</code></pre><p>An ensemble where a &#39;stack&#39; of learners is used for training and prediction.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.EnsembleMethods.VoteEnsemble" href="#AMLPipelineBase.EnsembleMethods.VoteEnsemble"><code>AMLPipelineBase.EnsembleMethods.VoteEnsemble</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VoteEnsemble(
   Dict( 
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Learners in voting committee.
      :learners =&gt; [PrunedTree(), Adaboost(), RandomForest()]
   )
)</code></pre><p>Set of machine learners employing majority vote to decide prediction.</p><p>Implements: <code>fit!</code>, <code>transform!</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{BestLearner, DataFrame, Vector}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{BestLearner, DataFrame, Vector}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(bls::BestLearner, instances::DataFrame, labels::Vector)</code></pre><p>Training phase:</p><ul><li>obtain learners as is if grid option is not present </li><li>generate learners if grid option is present </li><li>foreach prototype learner, generate learners with specific options found in grid</li><li>generate partitions</li><li>train each learner on each partition and obtain validation output</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{StackEnsemble, DataFrame, Vector}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{StackEnsemble, DataFrame, Vector}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(se::StackEnsemble, instances::DataFrame, labels::Vector)</code></pre><p>Training phase of the stack of learners.</p><ul><li>perform holdout to obtain indices for </li><li>partition learner and stacker training sets</li><li>partition training set for learners and stacker</li><li>train all learners</li><li>train stacker on learners&#39; outputs</li><li>build final model from the trained learners</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{VoteEnsemble, DataFrame, Vector}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{VoteEnsemble, DataFrame, Vector}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(ve::VoteEnsemble, instances::DataFrame, labels::Vector)</code></pre><p>Training phase of the ensemble.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{BestLearner, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{BestLearner, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(bls::BestLearner, instances::DataFrame)</code></pre><p>Choose the best learner based on cross-validation results and use it for prediction.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{StackEnsemble, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{StackEnsemble, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(se::StackEnsemble, instances::DataFrame)</code></pre><p>Build stacker instances and predict</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{VoteEnsemble, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{VoteEnsemble, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(ve::VoteEnsemble, instances::DataFrame)</code></pre><p>Prediction phase of the ensemble.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.CatFeatureSelector" href="#AMLPipelineBase.FeatureSelectors.CatFeatureSelector"><code>AMLPipelineBase.FeatureSelectors.CatFeatureSelector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CatFeatureSelector(Dict(:name =&gt; &quot;catf&quot;))</code></pre><p>Automatically extract categorical columns based on  inferred element types.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.CatNumDiscriminator" href="#AMLPipelineBase.FeatureSelectors.CatNumDiscriminator"><code>AMLPipelineBase.FeatureSelectors.CatNumDiscriminator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CatNumDiscriminator(
   Dict(
      :name =&gt; &quot;catnumdisc&quot;,
      :maxcategories =&gt; 24
   )
)</code></pre><p>Transform numeric columns to string (as categories)  if the count of their unique elements &lt;= maxcategories.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.CatNumDiscriminator-Tuple{Int64}" href="#AMLPipelineBase.FeatureSelectors.CatNumDiscriminator-Tuple{Int64}"><code>AMLPipelineBase.FeatureSelectors.CatNumDiscriminator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CatNumDiscriminator(maxcat::Int)</code></pre><p>Helper function for CatNumDiscriminator.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.FeatureSelector" href="#AMLPipelineBase.FeatureSelectors.FeatureSelector"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FeatureSelector(
   Dict(
     :name =&gt; &quot;featureselector&quot;,
     :columns =&gt; [col1, col2, ...]
   )
)</code></pre><p>Returns a dataframe of the selected columns.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Vararg{Int64}}" href="#AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Vararg{Int64}}"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FeatureSelector(cols::Vararg{Int})</code></pre><p>Helper function for FeatureSelector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Vector{Int64}}" href="#AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Vector{Int64}}"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FeatureSelector(cols::Vector{Int})</code></pre><p>Helper function for FeatureSelector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.NumFeatureSelector" href="#AMLPipelineBase.FeatureSelectors.NumFeatureSelector"><code>AMLPipelineBase.FeatureSelectors.NumFeatureSelector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NumFeatureSelector(Dict(:name=&gt;&quot;numfeatsel&quot;))</code></pre><p>Automatically extracts numeric features based on their inferred element types.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.MLBaseWrapper.StandardScaler" href="#TSML.MLBaseWrapper.StandardScaler"><code>TSML.MLBaseWrapper.StandardScaler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StandardScaler(
   Dict( 
      :impl_args =&gt; Dict(
          :center =&gt; true,
          :scale =&gt; true
      )
   )
)</code></pre><p>Standardizes each feature using (X - mean) / stddev. Will produce NaN if standard deviation is zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/mlbase.jl#L17-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.MLBaseWrapper.Standardize" href="#TSML.MLBaseWrapper.Standardize"><code>TSML.MLBaseWrapper.Standardize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Standardize(d::Int, m::Vector{Float64}, s::Vector{Float64})</code></pre><p>Standardization type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/mlbase.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(st::StandardScaler, features::T, labels::Vector=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Compute the parameters to center and scale.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/mlbase.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{StandardScaler, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{StandardScaler, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(st::StandardScaler, features::T)</code></pre><p>Apply the computed parameters for centering and scaling to new data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/mlbase.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.Monotonicers.Monotonicer" href="#TSML.Monotonicers.Monotonicer"><code>TSML.Monotonicers.Monotonicer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Monotonicer()</code></pre><p>Monotonic filter to detect and normalize two types of dataset: </p><ul><li>daily monotonic </li><li>entirely non-decreasing/non-increasing data</li></ul><p>Example: </p><pre><code class="nohighlight hljs">fname = joinpath(dirname(pathof(TSML)),&quot;../data/testdata.csv&quot;)
csvfilter = CSVDateValReader(Dict(:filename=&gt;fname,:dateformat=&gt;&quot;dd/mm/yyyy HH:MM&quot;))
valgator = DateValgator(Dict(:dateinterval=&gt;Dates.Hour(1)))
valnner = DateValNNer(Dict(:dateinterval=&gt;Dates.Hour(1)))
stfier = Statifier(Dict(:processmissing=&gt;true))
mono = Monotonicer(Dict())

mypipeline = @pipeline csvfilter |&gt; valgator |&gt; mono |&gt; stfier
result = fit_transform!(mypipeline)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/monotonicer.jl#L18-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(st::Monotonicer,features::T, labels::Vector=[])</code></pre><p>A function that checks if <code>features</code> are two-column data of  Dates and Values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/monotonicer.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Monotonicer, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Monotonicer, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(st::Monotonicer, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Normalize monotonic or daily monotonic data by taking the diffs and counting the flips.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/monotonicer.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.Normalizers.Normalizer" href="#TSML.Normalizers.Normalizer"><code>TSML.Normalizers.Normalizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Normalizer(Dict(
   :method =&gt; :zscore
))</code></pre><p>Transforms continuous features into normalized form such as zscore, unitrange, square-root, log, pca, ppca with parameter: </p><ul><li><code>:method</code> =&gt; <code>:zscore</code> or <code>:unitrange</code> or <code>:sqrt</code> or <code>:log</code> or <code>pca</code> or <code>ppca</code> or <code>fa</code></li><li><code>:zscore</code> =&gt; standard z-score with centering and scaling</li><li><code>:unitrange</code> =&gt; unit range normalization with centering and scaling</li><li><code>:sqrt</code> =&gt; square-root transform</li><li><code>:pca</code> =&gt; principal component analysis transform</li><li><code>:ppca</code> =&gt; probabilistic pca</li><li><code>:fa</code> =&gt; factor analysis</li><li><code>:log</code> =&gt; log transform</li></ul><p>Example:</p><pre><code class="nohighlight hljs">function generatedf()
    Random.seed!(123)
    gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
    gval1 = rand(length(gdate))
    gval2 = rand(length(gdate))
    gval3 = rand(length(gdate))
    X = DataFrame(Date=gdate,Value1=gval1,Value2=gval2,Value3=gval3)
    X
end

X = generatedf()
norm = Normalizer(Dict(:method =&gt; :zscore))
fit!(norm,X)
res=transform!(norm,X)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/normalizer.jl#L22-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(st::Statifier, features::T, labels::Vector=[])</code></pre><p>Validate argument features other than dates are continuous.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/normalizer.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Normalizer, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Normalizer, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(norm::Normalizer, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Compute statistics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/normalizer.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.Outliernicers.Outliernicer" href="#TSML.Outliernicers.Outliernicer"><code>TSML.Outliernicers.Outliernicer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Outliernicer(Dict(
   :dateinterval =&gt; Dates.Hour(1),
   :nnsize =&gt; 1,
   :missdirection =&gt; :symmetric,
   :scale =&gt; 1.25
))</code></pre><p>Detects outliers below or above (median-scale<em>iqr,median+scale</em>iqr) and calls DateValNNer to replace them with nearest neighbors.</p><p>Example:</p><pre><code class="nohighlight hljs">fname = joinpath(dirname(pathof(TSML)),&quot;../data/testdata.csv&quot;)
csvfilter = CSVDateValReader(Dict(:filename=&gt;fname,:dateformat=&gt;&quot;dd/mm/yyyy HH:MM&quot;))
valgator = DateValgator(Dict(:dateinterval=&gt;Dates.Hour(1)))
valnner = DateValNNer(Dict(:dateinterval=&gt;Dates.Hour(1)))
stfier = Statifier(Dict(:processmissing=&gt;true))
mono = Monotonicer(Dict())
outliernicer = Outliernicer(Dict(:dateinterval=&gt;Dates.Hour(1)))

mpipeline = @pipeline csvfilter |&gt; valgator |&gt; mono |&gt; valnner |&gt; outliernicer |&gt; stfier
results = fit_transform!(mpipeline)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/outliernicer.jl#L18-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(st::Outliernicer, features::T, labels::Vector=[])</code></pre><p>Check that <code>features</code> are two-colum data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/outliernicer.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Outliernicer, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Outliernicer, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(st::Outliernicer, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Locate outliers based on IQR factor and calls DateValNNer to replace them with nearest neighbors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/outliernicer.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Pipelines.ComboPipeline" href="#AMLPipelineBase.Pipelines.ComboPipeline"><code>AMLPipelineBase.Pipelines.ComboPipeline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ComboPipeline(machs::Vector{T}) where {T&lt;:Machine}</code></pre><p>Feature union pipeline which iteratively calls  <code>fit_transform</code> of each element and concatenate their output into one dataframe.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Pipelines.Pipeline" href="#AMLPipelineBase.Pipelines.Pipeline"><code>AMLPipelineBase.Pipelines.Pipeline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pipeline(machs::Vector{&lt;:Machine},args::Dict=Dict())</code></pre><p>Linear pipeline which iteratively calls and passes the result of <code>fit_transform</code> to the succeeding elements in the pipeline.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Pipelines.Pipeline-Tuple{Vararg{Machine}}" href="#AMLPipelineBase.Pipelines.Pipeline-Tuple{Vararg{Machine}}"><code>AMLPipelineBase.Pipelines.Pipeline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Pipeline(machs::Vararg{Machine})</code></pre><p>Helper function for Pipeline structure.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Pipelines.Pipeline-Tuple{Vector{&lt;:Machine}, Dict}" href="#AMLPipelineBase.Pipelines.Pipeline-Tuple{Vector{&lt;:Machine}, Dict}"><code>AMLPipelineBase.Pipelines.Pipeline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Pipeline(machs::Vector{&lt;:Machine},args::Dict=Dict())</code></pre><p>Helper function for Pipeline structure.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.Plotters.Plotter" href="#TSML.Plotters.Plotter"><code>TSML.Plotters.Plotter</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Plotter(   Dict(     :interactive =&gt; false,     :pdfoutput =&gt; false   ) )</p><p>Plots a TS by default but performs interactive plotting if specified during instance creation.</p><ul><li><code>:interactive</code> =&gt; boolean to indicate whether to use interactive plotting with <code>false</code> as default</li><li><code>:pdfoutput</code> =&gt; boolean to indicate whether ouput will be saved as pdf with <code>false</code> as default</li></ul><p>Example:</p><p>csvfilter = CSVDateValReader(Dict(:filename=&gt;fname,:dateformat=&gt;&quot;dd/mm/yyyy HH:MM&quot;)) pltr = Plotter(Dict(:interactive =&gt; false))</p><p>mpipeline = @pipeline csvfilter |&gt; pltr myplot = fit_transform!(mpipeline)</p><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/plotter.jl#L46-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fit!(pltr::Plotter, features::T, labels::Vector=[])</p><p>Check validity of <code>features</code>: 2-column Date,Val data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/plotter.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Plotter, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Plotter, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>transform!(pltr::Plotter, features::T) </p><p>Convert <code>missing</code> into <code>NaN</code> to allow plotting of discontinuities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/plotter.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.Statifiers.Statifier" href="#TSML.Statifiers.Statifier"><code>TSML.Statifiers.Statifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Statifier(Dict(
   :processmissing =&gt; true
))</code></pre><p>Outputs summary statistics such as mean, median, quartile, entropy, kurtosis, skewness, etc. with parameter: </p><ul><li><code>:processmissing</code> =&gt; <code>boolean</code> to indicate whether to include <code>missing</code> data stats.</li></ul><p>Example:</p><pre><code class="nohighlight hljs">dt=[missing;rand(1:10,3);missing;missing;missing;rand(1:5,3)]
dat = DataFrame(Date= DateTime(2017,12,31,1):Dates.Hour(1):DateTime(2017,12,31,10) |&gt; collect,
                Value = dt)

statfier = Statifier(Dict(:processmissing=&gt;false))

fit!(statfier,dat)
results=transform!(statfier,dat)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/statifier.jl#L20-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(st::Statifier, features::T=[], labels::Vector=[])</code></pre><p>Validate argument to make sure it&#39;s a 2-column format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/statifier.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!" href="#AMLPipelineBase.AbsTypes.transform!"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform!(st::Statifier, features::T=[])</code></pre><p>Compute statistics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/statifier.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSClassifiers.TSClassifier" href="#TSML.TSClassifiers.TSClassifier"><code>TSML.TSClassifiers.TSClassifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TSClassifier(
   Dict(
      # training directory
      :trdirectory =&gt; &quot;&quot;,
      :tstdirectory =&gt; &quot;&quot;,
      :modeldirectory =&gt; &quot;&quot;,
      :feature_range =&gt; 7:20,
      :juliarfmodelname =&gt; &quot;juliarfmodel.serialized&quot;,
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Options specific to this implementation.
      :impl_args =&gt; Dict(
         # Merge leaves having &gt;= purity_threshold CombineMLd purity.
         :purity_threshold =&gt; 1.0,
         # Maximum depth of the decision tree (default: no maximum).
         :max_depth =&gt; -1,
         # Minimum number of samples each leaf needs to have.
         :min_samples_leaf =&gt; 1,
         # Minimum number of samples in needed for a split.
         :min_samples_split =&gt; 2,
         # Minimum purity needed for a split.
         :min_purity_increase =&gt; 0.0
      )
   )
)</code></pre><p>Given a bunch of time-series with specific types. Get the statistical features of each, use these as inputs to RF classifier with output as the TS type, train and test. Another option is to use these stat features for clustering and check cluster quality. If accuracy is poor, add more stat features and repeat same process as outlined for training and testing. Assume that each time-series is named based on their type which will be used as target output. For example, temperature time series will be named as temperature?.csv where ? is an integer. Loop over each file in a directory, get stat and  record in a dictionary/dataframe, train/test. Default to using RandomForest  for classification of data types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/tsclassifier.jl#L20-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(tsc::TSClassifier, features::T=[], labels::Vector=[])</code></pre><p>Get the stats of each file, collect as dataframe, and train.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/tsclassifier.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!" href="#AMLPipelineBase.AbsTypes.transform!"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform!(tsc::TSClassifier, features::T=[])</code></pre><p>Apply the learned parameters to the new data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/tsclassifier.jl#L127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.CSVDateValReader" href="#TSML.ValDateFilters.CSVDateValReader"><code>TSML.ValDateFilters.CSVDateValReader</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CSVDateValReader(
   Dict(
      :filename =&gt; &quot;&quot;,
      :dateformat =&gt; &quot;&quot;
   )
)</code></pre><p>Reads csv file and parse date using the given format.</p><ul><li><code>:filename</code> =&gt; complete path including filename of csv file</li><li><code>:dateformat</code> =&gt; date format to parse</li></ul><p>Example:</p><pre><code class="nohighlight hljs">inputfile =joinpath(dirname(pathof(TSML)),&quot;../data/testdata.csv&quot;)
csvreader = CSVDateValReader(Dict(:filename=&gt;inputfile,:dateformat=&gt;&quot;d/m/y H:M&quot;))
fit!(csvreader)
df = transform!(csvreader)

# using pipeline workflow
filter1 = DateValgator()
filter2 = DateValNNer(Dict(:nnsize=&gt;1))
mypipeline = @pipeline csvreader |&gt; filter1 |&gt; filter2
fit!(mypipeline)
res=transform!(mypipeline)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L626-L654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.CSVDateValWriter" href="#TSML.ValDateFilters.CSVDateValWriter"><code>TSML.ValDateFilters.CSVDateValWriter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CSVDateValWriter(
   Dict(
      :filename =&gt; &quot;&quot;,
      :dateformat =&gt; &quot;&quot;
   )
)</code></pre><p>Writes the time series dataframe into a file with the given date format.</p><p>Example:</p><pre><code class="nohighlight hljs">inputfile =joinpath(dirname(pathof(TSML)),&quot;../data/testdata.csv&quot;)
outputfile = joinpath(&quot;/tmp/test.csv&quot;)
csvreader = CSVDateValReader(Dict(:filename=&gt;inputfile,:dateformat=&gt;&quot;d/m/y H:M&quot;))
csvwtr = CSVDateValWriter(Dict(:filename=&gt;outputfile,:dateformat=&gt;&quot;d/m/y H:M&quot;))
filter1 = DateValgator()
filter2 = DateValNNer(Dict(:nnsize=&gt;1))
mypipeline = @pipeline csvreader |&gt; filter1 |&gt; filter2 |&gt; csvwtr
res=fit_transform!(mypipeline)

# read back what was written to validate
csvreader = CSVDateValReader(Dict(:filename=&gt;outputfile,:dateformat=&gt;&quot;y-m-d HH:MM:SS&quot;))
fit!(csvreader)
transform!(csvreader)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L710-L737">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.DateValLinearImputer" href="#TSML.ValDateFilters.DateValLinearImputer"><code>TSML.ValDateFilters.DateValLinearImputer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DateValLinearImputer(
   Dict(
      :dateinterval =&gt; Dates.Hour(1),
  )
)</code></pre><p>Fills <code>missings</code> by linear interpolation.</p><ul><li><code>:dateinterval</code> =&gt; time period to use for grouping,</li></ul><p>Example:</p><pre><code class="nohighlight hljs">Random.seed!(123)
gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
gval = Array{Union{Missing,Float64}}(rand(length(gdate)))
gmissing = 50000
gndxmissing = Random.shuffle(1:length(gdate))[1:gmissing]
X = DataFrame(Date=gdate,Value=gval)
X.Value[gndxmissing] .= missing

dnnr = DateValLinearImputer()
fit!(dnnr,X)
transform!(dnnr,X)</code></pre><p>Implements: <code>fit!</code>, transform!`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L1011-L1038">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.DateValMultiNNer" href="#TSML.ValDateFilters.DateValMultiNNer"><code>TSML.ValDateFilters.DateValMultiNNer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DateValMultiNNer(
   Dict(
      :type =&gt; :knn # :linear
      :missdirection =&gt; :symmetric, #:reverse, # or :forward or :symmetric
      :dateinterval =&gt; Dates.Hour(1),
      :nnsize =&gt; 1,
      :strict =&gt; true,
      :aggregator =&gt; :median
  )
)</code></pre><p>Fills <code>missings</code> with their nearest-neighbors. It assumes that first column is a Date class and the other columns are Union{Missings,Real}. It uses DateValNNer and DateValizer+Impute to process each numeric column concatendate with the Date column.</p><ul><li><code>:type</code> =&gt; type of imputation which can be a linear interpolation or nearest neighbor</li><li><code>:missdirection</code> =&gt; direction to fill missing data (:symmetric, :reverse, :forward) </li><li><code>:dateinterval</code> =&gt; time period to use for grouping,</li><li><code>:nnsize</code> =&gt; neighborhood size,</li><li><code>:strict</code> =&gt; boolean value to indicate whether to be strict about replacement or not,</li><li>`:aggregator =&gt; function to aggregate based on date interval</li></ul><p>Example:</p><pre><code class="nohighlight hljs">Random.seed!(123)
gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
gval1 = Array{Union{Missing,Float64}}(rand(length(gdate)))
gval2 = Array{Union{Missing,Float64}}(rand(length(gdate)))
gval3 = Array{Union{Missing,Float64}}(rand(length(gdate)))
gmissing = 50000
gndxmissing1 = Random.shuffle(1:length(gdate))[1:gmissing]
gndxmissing2 = Random.shuffle(1:length(gdate))[1:gmissing]
gndxmissing3 = Random.shuffle(1:length(gdate))[1:gmissing]
X = DataFrame(Date=gdate,Temperature=gval1,Humidity=gval2,Ozone=gval3)
X.Temperature[gndxmissing1] .= missing
X.Humidity[gndxmissing2] .= missing
X.Ozone[gndxmissing3] .= missing

dnnr = DateValMultiNNer(Dict(
      :type=&gt;:linear,
      :dateinterval=&gt;Dates.Hour(1),
      :nnsize=&gt;10,
      :missdirection =&gt; :symmetric,
      :strict=&gt;true,
      :aggregator =&gt; :mean))
fit!(dnnr,X)
transform!(dnnr,X)</code></pre><p>Implements: <code>fit!</code>, transform!`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L856-L907">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.DateValNNer" href="#TSML.ValDateFilters.DateValNNer"><code>TSML.ValDateFilters.DateValNNer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DateValNNer(
   Dict(
      :missdirection =&gt; :symmetric, #:reverse, # or :forward or :symmetric
      :dateinterval =&gt; Dates.Hour(1),
      :nnsize =&gt; 1,
      :strict =&gt; true,
      :aggregator =&gt; :median
  )
)</code></pre><p>Fills <code>missings</code> with their nearest-neighbors.</p><ul><li><code>:missdirection</code> =&gt; direction to fill missing data (:symmetric, :reverse, :forward) </li><li><code>:dateinterval</code> =&gt; time period to use for grouping,</li><li><code>:nnsize</code> =&gt; neighborhood size,</li><li><code>:strict</code> =&gt; boolean value to indicate whether to be strict about replacement or not,</li><li>`:aggregator =&gt; function to aggregate based on date interval</li></ul><p>Example:</p><pre><code class="nohighlight hljs">Random.seed!(123)
gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
gval = Array{Union{Missing,Float64}}(rand(length(gdate)))
gmissing = 50000
gndxmissing = Random.shuffle(1:length(gdate))[1:gmissing]
X = DataFrame(Date=gdate,Value=gval)
X.Value[gndxmissing] .= missing

dnnr = DateValNNer(Dict(
      :dateinterval=&gt;Dates.Hour(1),
      :nnsize=&gt;10,
      :missdirection =&gt; :symmetric,
      :strict=&gt;true,
      :aggregator =&gt; :mean))
fit!(dnnr,X)
transform!(dnnr,X)</code></pre><p>Implements: <code>fit!</code>, transform!`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L467-L507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.DateValgator" href="#TSML.ValDateFilters.DateValgator"><code>TSML.ValDateFilters.DateValgator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DateValgator(args=Dict())
   Dict(
    :dateinterval =&gt; Dates.Hour(1),
    :aggregator =&gt; :median
  )
)</code></pre><p>Aggregates values based on date period specified.</p><p>Example:</p><pre><code class="nohighlight hljs"># generate random values with missing data
Random.seed!(123)
gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
gval = Array{Union{Missing,Float64}}(rand(length(gdate)))
gmissing = 50000
gndxmissing = Random.shuffle(1:length(gdate))[1:gmissing]
X = DataFrame(Date=gdate,Value=gval)
X.Value[gndxmissing] .= missing

dtvlmean = DateValgator(Dict(
      :dateinterval=&gt;Dates.Hour(1),
      :aggregator =&gt; :mean))
fit!(dtvlmean,X)
res = transform!(dtvlmean,X)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L226-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.DateValizer" href="#TSML.ValDateFilters.DateValizer"><code>TSML.ValDateFilters.DateValizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DateValizer(
   Dict(
    :medians =&gt; DataFrame(),
    :dateinterval =&gt; Dates.Hour(1)
  )
)</code></pre><p>Normalizes and cleans time series by replacing <code>missings</code> with global medians  computed based on time period groupings.</p><p>Example:</p><pre><code class="nohighlight hljs"># generate random values with missing data
Random.seed!(123)
gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
gval = Array{Union{Missing,Float64}}(rand(length(gdate)))
gmissing = 50000
gndxmissing = Random.shuffle(1:length(gdate))[1:gmissing]
X = DataFrame(Date=gdate,Value=gval)
X.Value[gndxmissing] .= missing

dvzr = DateValizer(Dict(:dateinterval=&gt;Dates.Hour(1)))
fit!(dvzr,X)
transform!(dvzr,X)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L331-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Dateifier" href="#TSML.ValDateFilters.Dateifier"><code>TSML.ValDateFilters.Dateifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Dateifier(args=Dict())
   Dict(
    :ahead =&gt; 1,
    :size =&gt; 7,
    :stride =&gt; 1
   )
)</code></pre><p>Converts a 1-D date series into sliding window matrix for ML training</p><p>Example: </p><pre><code class="nohighlight hljs">dtr = Dateifier(Dict())
lower = DateTime(2017,1,1)
upper = DateTime(2018,1,31)
dat=lower:Dates.Day(1):upper |&gt; collect
vals = rand(length(dat))
x=DataFrame(Date=dat,Value=vals)
fit!(dtr,x)
res = transform!(dtr,x)</code></pre><p>Implements: <code>&#39;fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L138-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Matrifier" href="#TSML.ValDateFilters.Matrifier"><code>TSML.ValDateFilters.Matrifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Matrifier(Dict(
   Dict(
    :ahead  =&gt; 1,
    :size   =&gt; 7,
    :stride =&gt; 1,
  )
)</code></pre><p>Converts a 1-D timeseries into sliding window matrix for ML training:</p><ul><li><code>:ahead</code>  =&gt; steps ahead to predict</li><li><code>:size</code>   =&gt; size of sliding window</li><li><code>:stride</code> =&gt; amount of overlap in sliding window</li></ul><p>Example:</p><pre><code class="nohighlight hljs">mtr = Matrifier(Dict(:ahead=&gt;24,:size=&gt;24,:stride=&gt;5))
lower = DateTime(2017,1,1)
upper = DateTime(2017,1,5)
dat=lower:Dates.Hour(1):upper |&gt; collect
vals = 1:length(dat)
x = DataFrame(Date=dat,Value=vals)
fit!(mtr,x)
res = transform!(mtr,x)</code></pre><p>Implements: <code>fit!</code>, <code>transform</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L35-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(dnnr::DateValMultiNNer,xx::T,y::Vector=[])</code></pre><p>Validates and checks arguments for errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L934-L938">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(mtr::Matrifier,xx::T,y::Vector=Vector())</code></pre><p>Checks and validate inputs are in correct structure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(dvmr::DateValgator,xx::T,y::Vector=[])</code></pre><p>Checks and validates arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L279-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(csvwtr::CSVDateValWriter,x::T=[],y::Vector=[])</code></pre><p>Makes sure filename and dateformat are not empty strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L754-L758">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(dvzr::DateValizer,xx::T,y::Vector=[])</code></pre><p>Validates input and computes global medians grouped by time period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L408-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(dtr::Dateifier,xx::T,y::Vector=[])</code></pre><p>Computes range of dates to be used during transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(dnnr::DateValNNer,xx::T,y::Vector=[])</code></pre><p>Validates and checks arguments for errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L527-L531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(csvrdr::CSVDateValReader,x::T=[],y::Vector=[])</code></pre><p>Makes sure filename and dateformat are not empty strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L672-L676">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(dnnr::DateValLinearImputer,xx::T,y::Vector=[])</code></pre><p>Validates and checks arguments for errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L1055-L1059">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!" href="#AMLPipelineBase.AbsTypes.transform!"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform!(csvrdr::CSVDateValReader,x::T=[])</code></pre><p>Uses CSV package to read the csv file and converts it to dataframe.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L689-L693">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{CSVDateValWriter, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{CSVDateValWriter, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(csvwtr::CSVDateValWriter,x::T)</code></pre><p>Uses CSV package to write the dataframe into a csv file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L771-L775">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{DateValLinearImputer, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{DateValLinearImputer, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(dnnr::DateValLinearImputer,xx::T)</code></pre><p>Replaces <code>missings</code> by linear interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L1071-L1075">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{DateValMultiNNer, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{DateValMultiNNer, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(dnnr::DateValMultiNNer,xx::T)</code></pre><p>Replaces <code>missings</code> by nearest neighbor or linear interpolation by looping over the dataset  for each column until all missing values are gone.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L955-L960">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{DateValNNer, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{DateValNNer, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(dnnr::DateValNNer,xx::T)</code></pre><p>Replaces <code>missings</code> by nearest neighbor looping over the dataset until all missing values are gone.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L545-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{DateValgator, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{DateValgator, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(dvmr::DateValgator,xx::T)</code></pre><p>Aggregates values grouped by date-time period using aggregate  function such as mean, median, maximum, minimum. Default is mean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L298-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{DateValizer, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{DateValizer, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(dvzr::DateValizer,xx::T) where {T&lt;:DataFrame}</code></pre><p>Replaces <code>missing</code> with the corresponding global medians with respect to time period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L430-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Dateifier, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Dateifier, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(dtr::Dateifier,xx::T)</code></pre><p>Transforms to day of the month, day of the week, etc</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L197-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Matrifier, DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Matrifier, DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(mtr::Matrifier,xx::T)</code></pre><p>Applies the parameters of sliding windows to create the corresponding matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/28d9ae2145a8af698716795f255422b2d8ee09bc/src/valdatefilters.jl#L97-L101">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/imputation/">« Imputation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Friday 15 April 2022 11:05">Friday 15 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
