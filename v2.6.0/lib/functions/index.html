<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types and Functions · TSML Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TSML Documentation</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">HOME</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../../tutorial/aggregators/">Aggregators and Imputers</a></li><li><a class="tocitem" href="../../tutorial/pipeline/">Pipeline</a></li><li><a class="tocitem" href="../../tutorial/statistics/">Statistical Metrics</a></li><li><a class="tocitem" href="../../tutorial/monotonic_plotting/">Monotonic Detection and Plotting</a></li><li><a class="tocitem" href="../../tutorial/tsclassifier/">TS Data Discovery</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/valueproc/">Value PreProcessing</a></li><li><a class="tocitem" href="../../man/dateproc/">Date PreProcessing</a></li><li><a class="tocitem" href="../../man/aggregation/">Aggregation</a></li><li><a class="tocitem" href="../../man/imputation/">Imputation</a></li></ul></li><li><span class="tocitem">ML Library</span><ul><li class="is-active"><a class="tocitem" href>Types and Functions</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Descriptions"><span>Descriptions</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ML Library</a></li><li class="is-active"><a href>Types and Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types and Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/IBM/TSML.jl/blob/master/docs/src/lib/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="lib_decisiontree"><a class="docs-heading-anchor" href="#lib_decisiontree">Types and Functions</a><a id="lib_decisiontree-1"></a><a class="docs-heading-anchor-permalink" href="#lib_decisiontree" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#AMLPipelineBase.BaseFilters.Imputer"><code>AMLPipelineBase.BaseFilters.Imputer</code></a></li><li><a href="#AMLPipelineBase.BaseFilters.OneHotEncoder"><code>AMLPipelineBase.BaseFilters.OneHotEncoder</code></a></li><li><a href="#AMLPipelineBase.BaseFilters.Wrapper"><code>AMLPipelineBase.BaseFilters.Wrapper</code></a></li><li><a href="#AMLPipelineBase.BaseFilters.createtransformer"><code>AMLPipelineBase.BaseFilters.createtransformer</code></a></li><li><a href="#AMLPipelineBase.BaselineModels.Baseline-Tuple{String}"><code>AMLPipelineBase.BaselineModels.Baseline</code></a></li><li><a href="#AMLPipelineBase.BaselineModels.Baseline"><code>AMLPipelineBase.BaselineModels.Baseline</code></a></li><li><a href="#AMLPipelineBase.BaselineModels.Identity-Tuple{String}"><code>AMLPipelineBase.BaselineModels.Identity</code></a></li><li><a href="#AMLPipelineBase.BaselineModels.Identity"><code>AMLPipelineBase.BaselineModels.Identity</code></a></li><li><a href="#AMLPipelineBase.CrossValidators.crossvalidate-Tuple{Machine,DataFrame,Array{T,1} where T,Function,Int64,Bool}"><code>AMLPipelineBase.CrossValidators.crossvalidate</code></a></li><li><a href="#AMLPipelineBase.DecisionTreeLearners.Adaboost"><code>AMLPipelineBase.DecisionTreeLearners.Adaboost</code></a></li><li><a href="#AMLPipelineBase.DecisionTreeLearners.PrunedTree"><code>AMLPipelineBase.DecisionTreeLearners.PrunedTree</code></a></li><li><a href="#AMLPipelineBase.DecisionTreeLearners.RandomForest"><code>AMLPipelineBase.DecisionTreeLearners.RandomForest</code></a></li><li><a href="#AMLPipelineBase.EnsembleMethods.BestLearner"><code>AMLPipelineBase.EnsembleMethods.BestLearner</code></a></li><li><a href="#AMLPipelineBase.EnsembleMethods.StackEnsemble"><code>AMLPipelineBase.EnsembleMethods.StackEnsemble</code></a></li><li><a href="#AMLPipelineBase.EnsembleMethods.VoteEnsemble"><code>AMLPipelineBase.EnsembleMethods.VoteEnsemble</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.CatFeatureSelector"><code>AMLPipelineBase.FeatureSelectors.CatFeatureSelector</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.CatNumDiscriminator"><code>AMLPipelineBase.FeatureSelectors.CatNumDiscriminator</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.CatNumDiscriminator-Tuple{Int64}"><code>AMLPipelineBase.FeatureSelectors.CatNumDiscriminator</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Array{Int64,1}}"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Vararg{Int64,N} where N}"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.FeatureSelector"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.NumFeatureSelector"><code>AMLPipelineBase.FeatureSelectors.NumFeatureSelector</code></a></li><li><a href="#TSML.MLBaseWrapper.StandardScaler"><code>TSML.MLBaseWrapper.StandardScaler</code></a></li><li><a href="#TSML.MLBaseWrapper.Standardize"><code>TSML.MLBaseWrapper.Standardize</code></a></li><li><a href="#TSML.Monotonicers.Monotonicer"><code>TSML.Monotonicers.Monotonicer</code></a></li><li><a href="#TSML.Normalizers.Normalizer"><code>TSML.Normalizers.Normalizer</code></a></li><li><a href="#TSML.Outliernicers.Outliernicer"><code>TSML.Outliernicers.Outliernicer</code></a></li><li><a href="#AMLPipelineBase.Pipelines.ComboPipeline"><code>AMLPipelineBase.Pipelines.ComboPipeline</code></a></li><li><a href="#AMLPipelineBase.Pipelines.Pipeline"><code>AMLPipelineBase.Pipelines.Pipeline</code></a></li><li><a href="#AMLPipelineBase.Pipelines.Pipeline-Tuple{Vararg{Machine,N} where N}"><code>AMLPipelineBase.Pipelines.Pipeline</code></a></li><li><a href="#AMLPipelineBase.Pipelines.Pipeline-Tuple{Array{var&quot;#s20&quot;,1} where var&quot;#s20&quot;&lt;:Machine,Dict}"><code>AMLPipelineBase.Pipelines.Pipeline</code></a></li><li><a href="#TSML.Plotters.Plotter"><code>TSML.Plotters.Plotter</code></a></li><li><a href="#TSML.Statifiers.Statifier"><code>TSML.Statifiers.Statifier</code></a></li><li><a href="#TSML.TSClassifiers.TSClassifier"><code>TSML.TSClassifiers.TSClassifier</code></a></li><li><a href="#TSML.ValDateFilters.CSVDateValReader"><code>TSML.ValDateFilters.CSVDateValReader</code></a></li><li><a href="#TSML.ValDateFilters.CSVDateValWriter"><code>TSML.ValDateFilters.CSVDateValWriter</code></a></li><li><a href="#TSML.ValDateFilters.DateValLinearImputer"><code>TSML.ValDateFilters.DateValLinearImputer</code></a></li><li><a href="#TSML.ValDateFilters.DateValMultiNNer"><code>TSML.ValDateFilters.DateValMultiNNer</code></a></li><li><a href="#TSML.ValDateFilters.DateValNNer"><code>TSML.ValDateFilters.DateValNNer</code></a></li><li><a href="#TSML.ValDateFilters.DateValgator"><code>TSML.ValDateFilters.DateValgator</code></a></li><li><a href="#TSML.ValDateFilters.DateValizer"><code>TSML.ValDateFilters.DateValizer</code></a></li><li><a href="#TSML.ValDateFilters.Dateifier"><code>TSML.ValDateFilters.Dateifier</code></a></li><li><a href="#TSML.ValDateFilters.Matrifier"><code>TSML.ValDateFilters.Matrifier</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.AbstractContext"><code>TSML.ValDateFilters.Imputers.AbstractContext</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.Chain-Tuple{Vararg{TSML.ValDateFilters.Imputers.Imputor,N} where N}"><code>TSML.ValDateFilters.Imputers.Chain</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.Chain"><code>TSML.ValDateFilters.Imputers.Chain</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.Context-Tuple{}"><code>TSML.ValDateFilters.Imputers.Context</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.DropObs"><code>TSML.ValDateFilters.Imputers.DropObs</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.DropVars"><code>TSML.ValDateFilters.Imputers.DropVars</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.Fill"><code>TSML.ValDateFilters.Imputers.Fill</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.ImputeError"><code>TSML.ValDateFilters.Imputers.ImputeError</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.Imputor"><code>TSML.ValDateFilters.Imputers.Imputor</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.Interpolate"><code>TSML.ValDateFilters.Imputers.Interpolate</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.LOCF"><code>TSML.ValDateFilters.Imputers.LOCF</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.NOCB"><code>TSML.ValDateFilters.Imputers.NOCB</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.WeightedContext-Tuple{StatsBase.AbstractWeights}"><code>TSML.ValDateFilters.Imputers.WeightedContext</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.chain-Tuple{Any,Vararg{Any,N} where N}"><code>TSML.ValDateFilters.Imputers.chain</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.chain!-Tuple{Any,Vararg{TSML.ValDateFilters.Imputers.Imputor,N} where N}"><code>TSML.ValDateFilters.Imputers.chain!</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.chain!-Tuple{Any,Function,Vararg{TSML.ValDateFilters.Imputers.Imputor,N} where N}"><code>TSML.ValDateFilters.Imputers.chain!</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.dropobs"><code>TSML.ValDateFilters.Imputers.dropobs</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.dropvars"><code>TSML.ValDateFilters.Imputers.dropvars</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.fill"><code>TSML.ValDateFilters.Imputers.fill</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.impute-Tuple{Any,TSML.ValDateFilters.Imputers.Imputor}"><code>TSML.ValDateFilters.Imputers.impute</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.impute-Tuple{Any,Vararg{Any,N} where N}"><code>TSML.ValDateFilters.Imputers.impute</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.impute!-Tuple{Any,TSML.ValDateFilters.Imputers.Imputor}"><code>TSML.ValDateFilters.Imputers.impute!</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.impute!-Tuple{Any,Function,Symbol,Vararg{Any,N} where N}"><code>TSML.ValDateFilters.Imputers.impute!</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.impute!-Tuple{Any,Symbol,Vararg{Any,N} where N}"><code>TSML.ValDateFilters.Imputers.impute!</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.impute!-Tuple{AbstractArray{T,2} where T,TSML.ValDateFilters.Imputers.Imputor}"><code>TSML.ValDateFilters.Imputers.impute!</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.impute!-Tuple{Any,TSML.ValDateFilters.Imputers.Chain}"><code>TSML.ValDateFilters.Imputers.impute!</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.interp"><code>TSML.ValDateFilters.Imputers.interp</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.ismissing!-Tuple{TSML.ValDateFilters.Imputers.AbstractContext,Any}"><code>TSML.ValDateFilters.Imputers.ismissing!</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.locf"><code>TSML.ValDateFilters.Imputers.locf</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.nocb"><code>TSML.ValDateFilters.Imputers.nocb</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.splitkwargs-Union{Tuple{T}, Tuple{Type{T},Vararg{Any,N} where N}} where T&lt;:TSML.ValDateFilters.Imputers.Imputor"><code>TSML.ValDateFilters.Imputers.splitkwargs</code></a></li><li><a href="#TSML.ValDateFilters.Imputers.srs"><code>TSML.ValDateFilters.Imputers.srs</code></a></li><li><a href="#TSML.SVMModels.SVMModel-Tuple{String,Dict}"><code>TSML.SVMModels.SVMModel</code></a></li><li><a href="#TSML.SVMModels.SVMModel"><code>TSML.SVMModels.SVMModel</code></a></li><li><a href="#TSML.SVMModels.SVMModel-Tuple{String}"><code>TSML.SVMModels.SVMModel</code></a></li></ul><h2 id="Descriptions"><a class="docs-heading-anchor" href="#Descriptions">Descriptions</a><a id="Descriptions-1"></a><a class="docs-heading-anchor-permalink" href="#Descriptions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaseFilters.Imputer" href="#AMLPipelineBase.BaseFilters.Imputer"><code>AMLPipelineBase.BaseFilters.Imputer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Imputer(
   Dict(
      # Imputation strategy.
      # Statistic that takes a vector such as mean or median.
      :strategy =&gt; mean
   )
)</code></pre><p>Imputes NaN values from Float64 features.</p><p>Implements <code>fit!</code> and <code>transform</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaseFilters.OneHotEncoder" href="#AMLPipelineBase.BaseFilters.OneHotEncoder"><code>AMLPipelineBase.BaseFilters.OneHotEncoder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OneHotEncoder(Dict(
   # Nominal columns
   :nominal_columns =&gt; Int[],

   # Nominal column values map. Key is column index, value is list of
   # possible values for that column.
   :nominal_column_values_map =&gt; Dict{Int,Any}()
))</code></pre><p>Transforms myinstances with nominal features into one-hot form and coerces the instance matrix to be of element type Float64.</p><p>Implements <code>fit!</code> and <code>transform</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaseFilters.Wrapper" href="#AMLPipelineBase.BaseFilters.Wrapper"><code>AMLPipelineBase.BaseFilters.Wrapper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Wrapper(
   default_args = Dict(
      :name =&gt; &quot;ohe-wrapper&quot;,
      # Transformer to call.
      :transformer =&gt; OneHotEncoder(),
      # Transformer args.
      :transformer_args =&gt; Dict()
   )
)</code></pre><p>Wraps around a transformer.</p><p>Implements <code>fit!</code> and <code>transform</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaseFilters.createtransformer" href="#AMLPipelineBase.BaseFilters.createtransformer"><code>AMLPipelineBase.BaseFilters.createtransformer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">createtransformer(prototype::Transformer, args=Dict())</code></pre><p>Create transformer</p><ul><li><code>prototype</code>: prototype transformer to base new transformer on</li><li><code>options</code>: additional options to override prototype&#39;s options</li></ul><p>Returns: new transformer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaselineModels.Baseline" href="#AMLPipelineBase.BaselineModels.Baseline"><code>AMLPipelineBase.BaselineModels.Baseline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Baseline(
   default_args = Dict(
       :name =&gt; &quot;baseline&quot;,
      :output =&gt; :class,
      :strat =&gt; mode
   )
)</code></pre><p>Baseline model that returns the mode during classification.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaselineModels.Baseline-Tuple{String}" href="#AMLPipelineBase.BaselineModels.Baseline-Tuple{String}"><code>AMLPipelineBase.BaselineModels.Baseline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Baseline(name::String,opt...)</code></pre><p>Helper function</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaselineModels.Identity" href="#AMLPipelineBase.BaselineModels.Identity"><code>AMLPipelineBase.BaselineModels.Identity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Identity(args=Dict())</code></pre><p>Returns the input as output.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaselineModels.Identity-Tuple{String}" href="#AMLPipelineBase.BaselineModels.Identity-Tuple{String}"><code>AMLPipelineBase.BaselineModels.Identity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Baseline(name::String,opt...)</code></pre><p>Helper function</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{Baseline,DataFrame,Array{T,1} where T}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{Baseline,DataFrame,Array{T,1} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(bsl::Baseline,x::DataFrame,y::Vector)</code></pre><p>Get the mode of the training data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{Identity,DataFrame,Array{T,1} where T}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{Identity,DataFrame,Array{T,1} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(idy::Identity,x::DataFrame,y::Vector)</code></pre><p>Does nothing.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Baseline,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Baseline,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(bsl::Baseline,x::DataFrame)</code></pre><p>Return the mode in classification.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Identity,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Identity,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(idy::Identity,x::DataFrame)</code></pre><p>Return the input as output.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.CrossValidators.crossvalidate-Tuple{Machine,DataFrame,Array{T,1} where T,Function,Int64,Bool}" href="#AMLPipelineBase.CrossValidators.crossvalidate-Tuple{Machine,DataFrame,Array{T,1} where T,Function,Int64,Bool}"><code>AMLPipelineBase.CrossValidators.crossvalidate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crossvalidate(pl::Machine,X::DataFrame,Y::Vector,pfunc::Function,kfolds=10)</code></pre><p>Run K-fold crossvalidation where:</p><ul><li><code>pfunc</code> is a performance metric</li><li><code>X</code> and <code>Y</code> are input and target </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.DecisionTreeLearners.Adaboost" href="#AMLPipelineBase.DecisionTreeLearners.Adaboost"><code>AMLPipelineBase.DecisionTreeLearners.Adaboost</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Adaboost(
  Dict(
    :output =&gt; :class,
    :num_iterations =&gt; 7
  )
)</code></pre><p>Adaboosted decision tree stumps. See <a href="https://github.com/bensadeghi/DecisionTree.jl">DecisionTree.jl&#39;s documentation</a></p><p>Hyperparameters:</p><ul><li><code>:num_iterations</code> =&gt; 7 (number of iterations of AdaBoost)</li></ul><p>Implements <code>fit!</code>, <code>transform!</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.DecisionTreeLearners.PrunedTree" href="#AMLPipelineBase.DecisionTreeLearners.PrunedTree"><code>AMLPipelineBase.DecisionTreeLearners.PrunedTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PrunedTree(
  Dict(
    :purity_threshold =&gt; 1.0,
    :max_depth =&gt; -1,
    :min_samples_leaf =&gt; 1,
    :min_samples_split =&gt; 2,
    :min_purity_increase =&gt; 0.0
  )
)</code></pre><p>Decision tree classifier.   See <a href="https://github.com/bensadeghi/DecisionTree.jl">DecisionTree.jl&#39;s documentation</a></p><p>Hyperparmeters:</p><ul><li><code>:purity_threshold</code> =&gt; 1.0 (merge leaves having &gt;=thresh combined purity)</li><li><code>:max_depth</code> =&gt; -1 (maximum depth of the decision tree)</li><li><code>:min_samples_leaf</code> =&gt; 1 (the minimum number of samples each leaf needs to have)</li><li><code>:min_samples_split</code> =&gt; 2 (the minimum number of samples in needed for a split)</li><li><code>:min_purity_increase</code> =&gt; 0.0 (minimum purity needed for a split)</li></ul><p>Implements <code>fit!</code>, <code>transform!</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.DecisionTreeLearners.RandomForest" href="#AMLPipelineBase.DecisionTreeLearners.RandomForest"><code>AMLPipelineBase.DecisionTreeLearners.RandomForest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RandomForest(
  Dict(
    :output =&gt; :class,
    :num_subfeatures =&gt; 0,
    :num_trees =&gt; 10,
    :partial_sampling =&gt; 0.7,
    :max_depth =&gt; -1
  )
)</code></pre><p>Random forest classification.  See <a href="https://github.com/bensadeghi/DecisionTree.jl">DecisionTree.jl&#39;s documentation</a></p><p>Hyperparmeters:</p><ul><li><code>:num_subfeatures</code> =&gt; 0  (number of features to consider at random per split)</li><li><code>:num_trees</code> =&gt; 10 (number of trees to train)</li><li><code>:partial_sampling</code> =&gt; 0.7 (fraction of samples to train each tree on)</li><li><code>:max_depth</code> =&gt; -1 (maximum depth of the decision trees)</li><li><code>:min_samples_leaf</code> =&gt; 1 (the minimum number of samples each leaf needs to have)</li><li><code>:min_samples_split</code> =&gt; 2 (the minimum number of samples in needed for a split)</li><li><code>:min_purity_increase</code> =&gt; 0.0 (minimum purity needed for a split)</li></ul><p>Implements <code>fit!</code>, <code>transform!</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{Adaboost,DataFrame,Array{T,1} where T}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{Adaboost,DataFrame,Array{T,1} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(adaboost::Adaboost, features::DataFrame, labels::Vector)</code></pre><p>Optimize the hyperparameters of <code>Adaboost</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{PrunedTree,DataFrame,Array{T,1} where T}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{PrunedTree,DataFrame,Array{T,1} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(tree::PrunedTree, features::DataFrame, labels::Vector)</code></pre><p>Optimize the hyperparameters of <code>PrunedTree</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{RandomForest,DataFrame,Array{T,1} where T}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{RandomForest,DataFrame,Array{T,1} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(forest::RandomForest, features::T, labels::Vector) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Optimize the parameters of the <code>RandomForest</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Adaboost,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Adaboost,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(adaboost::Adaboost, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Predict using the optimized hyperparameters of the trained <code>Adaboost</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{PrunedTree,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{PrunedTree,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(ptree::PrunedTree, features::DataFrame)</code></pre><p>Predict using the optimized hyperparameters of the trained <code>PrunedTree</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{RandomForest,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{RandomForest,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(forest::RandomForest, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Predict using the optimized hyperparameters of the trained <code>RandomForest</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.EnsembleMethods.BestLearner" href="#AMLPipelineBase.EnsembleMethods.BestLearner"><code>AMLPipelineBase.EnsembleMethods.BestLearner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BestLearner(
   Dict(
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Function to return partitions of instance indices.
      :partition_generator =&gt; (instances, labels) -&gt; kfold(size(instances, 1), 5),
      # Function that selects the best learner by index.
      # Arg learner_partition_scores is a (learner, partition) score matrix.
      :selection_function =&gt; (learner_partition_scores) -&gt; findmax(mean(learner_partition_scores, dims=2))[2],      
      # Score type returned by score() using respective output.
      :score_type =&gt; Real,
      # Candidate learners.
      :learners =&gt; [PrunedTree(), Adaboost(), RandomForest()],
      # Options grid for learners, to search through by BestLearner.
      # Format is [learner_1_options, learner_2_options, ...]
      # where learner_options is same as a learner&#39;s options but
      # with a list of values instead of scalar.
      :learner_options_grid =&gt; nothing
   )
)</code></pre><p>Selects best learner from the set by performing a  grid search on learners if grid option is indicated.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.EnsembleMethods.StackEnsemble" href="#AMLPipelineBase.EnsembleMethods.StackEnsemble"><code>AMLPipelineBase.EnsembleMethods.StackEnsemble</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StackEnsemble(
   Dict(    
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Set of learners that produce feature space for stacker.
      :learners =&gt; [PrunedTree(), Adaboost(), RandomForest()],
      # Machine learner that trains on set of learners&#39; outputs.
      :stacker =&gt; RandomForest(),
      # Proportion of training set left to train stacker itself.
      :stacker_training_proportion =&gt; 0.3,
      # Provide original features on top of learner outputs to stacker.
      :keep_original_features =&gt; false
   )
)</code></pre><p>An ensemble where a &#39;stack&#39; of learners is used for training and prediction.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.EnsembleMethods.VoteEnsemble" href="#AMLPipelineBase.EnsembleMethods.VoteEnsemble"><code>AMLPipelineBase.EnsembleMethods.VoteEnsemble</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VoteEnsemble(
   Dict( 
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Learners in voting committee.
      :learners =&gt; [PrunedTree(), Adaboost(), RandomForest()]
   )
)</code></pre><p>Set of machine learners employing majority vote to decide prediction.</p><p>Implements: <code>fit!</code>, <code>transform!</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{BestLearner,DataFrame,Array{T,1} where T}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{BestLearner,DataFrame,Array{T,1} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(bls::BestLearner, instances::DataFrame, labels::Vector)</code></pre><p>Training phase:</p><ul><li>obtain learners as is if grid option is not present </li><li>generate learners if grid option is present </li><li>foreach prototype learner, generate learners with specific options found in grid</li><li>generate partitions</li><li>train each learner on each partition and obtain validation output</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{StackEnsemble,DataFrame,Array{T,1} where T}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{StackEnsemble,DataFrame,Array{T,1} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(se::StackEnsemble, instances::DataFrame, labels::Vector)</code></pre><p>Training phase of the stack of learners.</p><ul><li>perform holdout to obtain indices for </li><li>partition learner and stacker training sets</li><li>partition training set for learners and stacker</li><li>train all learners</li><li>train stacker on learners&#39; outputs</li><li>build final model from the trained learners</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{VoteEnsemble,DataFrame,Array{T,1} where T}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{VoteEnsemble,DataFrame,Array{T,1} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(ve::VoteEnsemble, instances::DataFrame, labels::Vector)</code></pre><p>Training phase of the ensemble.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{BestLearner,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{BestLearner,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(bls::BestLearner, instances::DataFrame)</code></pre><p>Choose the best learner based on cross-validation results and use it for prediction.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{StackEnsemble,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{StackEnsemble,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(se::StackEnsemble, instances::DataFrame)</code></pre><p>Build stacker instances and predict</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{VoteEnsemble,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{VoteEnsemble,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(ve::VoteEnsemble, instances::DataFrame)</code></pre><p>Prediction phase of the ensemble.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.CatFeatureSelector" href="#AMLPipelineBase.FeatureSelectors.CatFeatureSelector"><code>AMLPipelineBase.FeatureSelectors.CatFeatureSelector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CatFeatureSelector(Dict(:name =&gt; &quot;catf&quot;))</code></pre><p>Automatically extract categorical columns based on  inferred element types.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.CatNumDiscriminator" href="#AMLPipelineBase.FeatureSelectors.CatNumDiscriminator"><code>AMLPipelineBase.FeatureSelectors.CatNumDiscriminator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CatNumDiscriminator(
   Dict(
      :name =&gt; &quot;catnumdisc&quot;,
      :maxcategories =&gt; 24
   )
)</code></pre><p>Transform numeric columns to string (as categories)  if the count of their unique elements &lt;= maxcategories.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.CatNumDiscriminator-Tuple{Int64}" href="#AMLPipelineBase.FeatureSelectors.CatNumDiscriminator-Tuple{Int64}"><code>AMLPipelineBase.FeatureSelectors.CatNumDiscriminator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CatNumDiscriminator(maxcat::Int)</code></pre><p>Helper function for CatNumDiscriminator.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.FeatureSelector" href="#AMLPipelineBase.FeatureSelectors.FeatureSelector"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FeatureSelector(
   Dict(
     :name =&gt; &quot;featureselector&quot;,
     :columns =&gt; [col1, col2, ...]
   )
)</code></pre><p>Returns a dataframe of the selected columns.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Array{Int64,1}}" href="#AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Array{Int64,1}}"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FeatureSelector(cols::Vector{Int})</code></pre><p>Helper function for FeatureSelector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Vararg{Int64,N} where N}" href="#AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Vararg{Int64,N} where N}"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FeatureSelector(cols::Vararg{Int})</code></pre><p>Helper function for FeatureSelector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.NumFeatureSelector" href="#AMLPipelineBase.FeatureSelectors.NumFeatureSelector"><code>AMLPipelineBase.FeatureSelectors.NumFeatureSelector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NumFeatureSelector(Dict(:name=&gt;&quot;numfeatsel&quot;))</code></pre><p>Automatically extracts numeric features based on their inferred element types.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.MLBaseWrapper.StandardScaler" href="#TSML.MLBaseWrapper.StandardScaler"><code>TSML.MLBaseWrapper.StandardScaler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StandardScaler(
   Dict( 
      :impl_args =&gt; Dict(
          :center =&gt; true,
          :scale =&gt; true
      )
   )
)</code></pre><p>Standardizes each feature using (X - mean) / stddev. Will produce NaN if standard deviation is zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/mlbase.jl#L17-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.MLBaseWrapper.Standardize" href="#TSML.MLBaseWrapper.Standardize"><code>TSML.MLBaseWrapper.Standardize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Standardize(d::Int, m::Vector{Float64}, s::Vector{Float64})</code></pre><p>Standardization type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/mlbase.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(st::StandardScaler, features::T, labels::Vector=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Compute the parameters to center and scale.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/mlbase.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{StandardScaler,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{StandardScaler,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(st::StandardScaler, features::T)  where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Apply the computed parameters for centering and scaling to new data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/mlbase.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.Monotonicers.Monotonicer" href="#TSML.Monotonicers.Monotonicer"><code>TSML.Monotonicers.Monotonicer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Monotonicer()</code></pre><p>Monotonic filter to detect and normalize two types of dataset: </p><ul><li>daily monotonic </li><li>entirely non-decreasing/non-increasing data</li></ul><p>Example: </p><pre><code class="language-none">fname = joinpath(dirname(pathof(TSML)),&quot;../data/testdata.csv&quot;)
csvfilter = CSVDateValReader(Dict(:filename=&gt;fname,:dateformat=&gt;&quot;dd/mm/yyyy HH:MM&quot;))
valgator = DateValgator(Dict(:dateinterval=&gt;Dates.Hour(1)))
valnner = DateValNNer(Dict(:dateinterval=&gt;Dates.Hour(1)))
stfier = Statifier(Dict(:processmissing=&gt;true))
mono = Monotonicer(Dict())

mypipeline = @pipeline csvfilter |&gt; valgator |&gt; mono |&gt; stfier
result = fit_transform!(mypipeline)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/monotonicer.jl#L18-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(st::Monotonicer,features::T, labels::Vector=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>A function that checks if <code>features</code> are two-column data of  Dates and Values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/monotonicer.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Monotonicer,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Monotonicer,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(st::Monotonicer, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Normalize monotonic or daily monotonic data by taking the diffs and counting the flips.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/monotonicer.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.Normalizers.Normalizer" href="#TSML.Normalizers.Normalizer"><code>TSML.Normalizers.Normalizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Normalizer(Dict(
   :method =&gt; :zscore
))</code></pre><p>Transforms continuous features into normalized form such as zscore, unitrange, square-root, log, pca, ppca with parameter: </p><ul><li><code>:method</code> =&gt; <code>:zscore</code> or <code>:unitrange</code> or <code>:sqrt</code> or <code>:log</code> or <code>pca</code> or <code>ppca</code> or <code>fa</code></li><li><code>:zscore</code> =&gt; standard z-score with centering and scaling</li><li><code>:unitrange</code> =&gt; unit range normalization with centering and scaling</li><li><code>:sqrt</code> =&gt; square-root transform</li><li><code>:pca</code> =&gt; principal component analysis transform</li><li><code>:ppca</code> =&gt; probabilistic pca</li><li><code>:fa</code> =&gt; factor analysis</li><li><code>:log</code> =&gt; log transform</li></ul><p>Example:</p><pre><code class="language-none">function generatedf()
    Random.seed!(123)
    gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
    gval1 = rand(length(gdate))
    gval2 = rand(length(gdate))
    gval3 = rand(length(gdate))
    X = DataFrame(Date=gdate,Value1=gval1,Value2=gval2,Value3=gval3)
    X
end

X = generatedf()
norm = Normalizer(Dict(:method =&gt; :zscore))
fit!(norm,X)
res=transform!(norm,X)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/normalizer.jl#L21-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(st::Statifier, features::T, labels::Vector=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Validate argument features other than dates are continuous.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/normalizer.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Normalizer,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Normalizer,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(norm::Normalizer, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Compute statistics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/normalizer.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.Outliernicers.Outliernicer" href="#TSML.Outliernicers.Outliernicer"><code>TSML.Outliernicers.Outliernicer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Outliernicer(Dict(
   :dateinterval =&gt; Dates.Hour(1),
   :nnsize =&gt; 1,
   :missdirection =&gt; :symmetric,
   :scale =&gt; 1.25
))</code></pre><p>Detects outliers below or above (median-scale<em>iqr,median+scale</em>iqr) and calls DateValNNer to replace them with nearest neighbors.</p><p>Example:</p><pre><code class="language-none">fname = joinpath(dirname(pathof(TSML)),&quot;../data/testdata.csv&quot;)
csvfilter = CSVDateValReader(Dict(:filename=&gt;fname,:dateformat=&gt;&quot;dd/mm/yyyy HH:MM&quot;))
valgator = DateValgator(Dict(:dateinterval=&gt;Dates.Hour(1)))
valnner = DateValNNer(Dict(:dateinterval=&gt;Dates.Hour(1)))
stfier = Statifier(Dict(:processmissing=&gt;true))
mono = Monotonicer(Dict())
outliernicer = Outliernicer(Dict(:dateinterval=&gt;Dates.Hour(1)))

mpipeline = @pipeline csvfilter |&gt; valgator |&gt; mono |&gt; valnner |&gt; outliernicer |&gt; stfier
results = fit_transform!(mpipeline)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/outliernicer.jl#L18-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(st::Outliernicer, features::T, labels::Vector=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Check that <code>features</code> are two-colum data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/outliernicer.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Outliernicer,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Outliernicer,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(st::Outliernicer, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Locate outliers based on IQR factor and calls DateValNNer to replace them with nearest neighbors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/outliernicer.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Pipelines.ComboPipeline" href="#AMLPipelineBase.Pipelines.ComboPipeline"><code>AMLPipelineBase.Pipelines.ComboPipeline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ComboPipeline(machs::Vector{T}) where {T&lt;:Machine}</code></pre><p>Feature union pipeline which iteratively calls  <code>fit_transform</code> of each element and concatenate their output into one dataframe.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Pipelines.Pipeline" href="#AMLPipelineBase.Pipelines.Pipeline"><code>AMLPipelineBase.Pipelines.Pipeline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pipeline(machs::Vector{&lt;:Machine},args::Dict=Dict())</code></pre><p>Linear pipeline which iteratively calls and passes the result of <code>fit_transform</code> to the succeeding elements in the pipeline.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Pipelines.Pipeline-Tuple{Array{var&quot;#s20&quot;,1} where var&quot;#s20&quot;&lt;:Machine,Dict}" href="#AMLPipelineBase.Pipelines.Pipeline-Tuple{Array{var&quot;#s20&quot;,1} where var&quot;#s20&quot;&lt;:Machine,Dict}"><code>AMLPipelineBase.Pipelines.Pipeline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Pipeline(machs::Vector{&lt;:Machine},args::Dict=Dict())</code></pre><p>Helper function for Pipeline structure.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Pipelines.Pipeline-Tuple{Vararg{Machine,N} where N}" href="#AMLPipelineBase.Pipelines.Pipeline-Tuple{Vararg{Machine,N} where N}"><code>AMLPipelineBase.Pipelines.Pipeline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Pipeline(machs::Vararg{Machine})</code></pre><p>Helper function for Pipeline structure.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.Plotters.Plotter" href="#TSML.Plotters.Plotter"><code>TSML.Plotters.Plotter</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Plotter(   Dict(     :interactive =&gt; false,     :pdfoutput =&gt; false   ) )</p><p>Plots a TS by default but performs interactive plotting if specified during instance creation.</p><ul><li><code>:interactive</code> =&gt; boolean to indicate whether to use interactive plotting with <code>false</code> as default</li><li><code>:pdfoutput</code> =&gt; boolean to indicate whether ouput will be saved as pdf with <code>false</code> as default</li></ul><p>Example:</p><p>csvfilter = CSVDateValReader(Dict(:filename=&gt;fname,:dateformat=&gt;&quot;dd/mm/yyyy HH:MM&quot;)) pltr = Plotter(Dict(:interactive =&gt; false))</p><p>mpipeline = @pipeline csvfilter |&gt; pltr myplot = fit_transform!(mpipeline)</p><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/plotter.jl#L46-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fit!(pltr::Plotter, features::T, labels::Vector=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</p><p>Check validity of <code>features</code>: 2-column Date,Val data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/plotter.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Plotter,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Plotter,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>transform!(pltr::Plotter, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</p><p>Convert <code>missing</code> into <code>NaN</code> to allow plotting of discontinuities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/plotter.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.Statifiers.Statifier" href="#TSML.Statifiers.Statifier"><code>TSML.Statifiers.Statifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Statifier(Dict(
   :processmissing =&gt; true
))</code></pre><p>Outputs summary statistics such as mean, median, quartile, entropy, kurtosis, skewness, etc. with parameter: </p><ul><li><code>:processmissing</code> =&gt; <code>boolean</code> to indicate whether to include <code>missing</code> data stats.</li></ul><p>Example:</p><pre><code class="language-none">dt=[missing;rand(1:10,3);missing;missing;missing;rand(1:5,3)]
dat = DataFrame(Date= DateTime(2017,12,31,1):Dates.Hour(1):DateTime(2017,12,31,10) |&gt; collect,
                Value = dt)

statfier = Statifier(Dict(:processmissing=&gt;false))

fit!(statfier,dat)
results=transform!(statfier,dat)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/statifier.jl#L22-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(st::Statifier, features::T=[], labels::Vector=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Validate argument to make sure it&#39;s a 2-column format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/statifier.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!" href="#AMLPipelineBase.AbsTypes.transform!"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transform!(st::Statifier, features::T=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Compute statistics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/statifier.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSClassifiers.TSClassifier" href="#TSML.TSClassifiers.TSClassifier"><code>TSML.TSClassifiers.TSClassifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TSClassifier(
   Dict(
      # training directory
      :trdirectory =&gt; &quot;&quot;,
      :tstdirectory =&gt; &quot;&quot;,
      :modeldirectory =&gt; &quot;&quot;,
      :feature_range =&gt; 7:20,
      :juliarfmodelname =&gt; &quot;juliarfmodel.serialized&quot;,
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Options specific to this implementation.
      :impl_args =&gt; Dict(
         # Merge leaves having &gt;= purity_threshold CombineMLd purity.
         :purity_threshold =&gt; 1.0,
         # Maximum depth of the decision tree (default: no maximum).
         :max_depth =&gt; -1,
         # Minimum number of samples each leaf needs to have.
         :min_samples_leaf =&gt; 1,
         # Minimum number of samples in needed for a split.
         :min_samples_split =&gt; 2,
         # Minimum purity needed for a split.
         :min_purity_increase =&gt; 0.0
      )
   )
)</code></pre><p>Given a bunch of time-series with specific types. Get the statistical features of each, use these as inputs to RF classifier with output as the TS type, train and test. Another option is to use these stat features for clustering and check cluster quality. If accuracy is poor, add more stat features and repeat same process as outlined for training and testing. Assume that each time-series is named based on their type which will be used as target output. For example, temperature time series will be named as temperature?.csv where ? is an integer. Loop over each file in a directory, get stat and  record in a dictionary/dataframe, train/test. Default to using RandomForest  for classification of data types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/tsclassifier.jl#L21-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(tsc::TSClassifier, features::T=[], labels::Vector=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Get the stats of each file, collect as dataframe, and train.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/tsclassifier.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!" href="#AMLPipelineBase.AbsTypes.transform!"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transform!(tsc::TSClassifier, features::T=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Apply the learned parameters to the new data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/tsclassifier.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.CSVDateValReader" href="#TSML.ValDateFilters.CSVDateValReader"><code>TSML.ValDateFilters.CSVDateValReader</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CSVDateValReader(
   Dict(
      :filename =&gt; &quot;&quot;,
      :dateformat =&gt; &quot;&quot;
   )
)</code></pre><p>Reads csv file and parse date using the given format.</p><ul><li><code>:filename</code> =&gt; complete path including filename of csv file</li><li><code>:dateformat</code> =&gt; date format to parse</li></ul><p>Example:</p><pre><code class="language-none">inputfile =joinpath(dirname(pathof(TSML)),&quot;../data/testdata.csv&quot;)
csvreader = CSVDateValReader(Dict(:filename=&gt;inputfile,:dateformat=&gt;&quot;d/m/y H:M&quot;))
fit!(csvreader)
df = transform!(csvreader)

# using pipeline workflow
filter1 = DateValgator()
filter2 = DateValNNer(Dict(:nnsize=&gt;1))
mypipeline = @pipeline csvreader |&gt; filter1 |&gt; filter2
fit!(mypipeline)
res=transform!(mypipeline)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L568-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.CSVDateValWriter" href="#TSML.ValDateFilters.CSVDateValWriter"><code>TSML.ValDateFilters.CSVDateValWriter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CSVDateValWriter(
   Dict(
      :filename =&gt; &quot;&quot;,
      :dateformat =&gt; &quot;&quot;
   )
)</code></pre><p>Writes the time series dataframe into a file with the given date format.</p><p>Example:</p><pre><code class="language-none">inputfile =joinpath(dirname(pathof(TSML)),&quot;../data/testdata.csv&quot;)
outputfile = joinpath(&quot;/tmp/test.csv&quot;)
csvreader = CSVDateValReader(Dict(:filename=&gt;inputfile,:dateformat=&gt;&quot;d/m/y H:M&quot;))
csvwtr = CSVDateValWriter(Dict(:filename=&gt;outputfile,:dateformat=&gt;&quot;d/m/y H:M&quot;))
filter1 = DateValgator()
filter2 = DateValNNer(Dict(:nnsize=&gt;1))
mypipeline = @pipeline csvreader |&gt; filter1 |&gt; filter2 |&gt; csvwtr
res=fit_transform!(mypipeline)

# read back what was written to validate
csvreader = CSVDateValReader(Dict(:filename=&gt;outputfile,:dateformat=&gt;&quot;y-m-d HH:MM:SS&quot;))
fit!(csvreader)
transform!(csvreader)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L642-L669">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.DateValLinearImputer" href="#TSML.ValDateFilters.DateValLinearImputer"><code>TSML.ValDateFilters.DateValLinearImputer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DateValLinearImputer(
   Dict(
      :dateinterval =&gt; Dates.Hour(1),
  )
)</code></pre><p>Fills <code>missings</code> by linear interpolation.</p><ul><li><code>:dateinterval</code> =&gt; time period to use for grouping,</li></ul><p>Example:</p><pre><code class="language-none">Random.seed!(123)
gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
gval = Array{Union{Missing,Float64}}(rand(length(gdate)))
gmissing = 50000
gndxmissing = Random.shuffle(1:length(gdate))[1:gmissing]
X = DataFrame(Date=gdate,Value=gval)
X.Value[gndxmissing] .= missing

dnnr = DateValLinearImputer()
fit!(dnnr,X)
transform!(dnnr,X)</code></pre><p>Implements: <code>fit!</code>, transform!`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L923-L950">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.DateValMultiNNer" href="#TSML.ValDateFilters.DateValMultiNNer"><code>TSML.ValDateFilters.DateValMultiNNer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DateValMultiNNer(
   Dict(
      :type =&gt; :knn # :linear
      :missdirection =&gt; :symmetric, #:reverse, # or :forward or :symmetric
      :dateinterval =&gt; Dates.Hour(1),
      :nnsize =&gt; 1,
      :strict =&gt; true,
      :aggregator =&gt; :median
  )
)</code></pre><p>Fills <code>missings</code> with their nearest-neighbors. It assumes that first column is a Date class and the other columns are Union{Missings,Real}. It uses DateValNNer and DateValizer+Impute to process each numeric column concatendate with the Date column.</p><ul><li><code>:type</code> =&gt; type of imputation which can be a linear interpolation or nearest neighbor</li><li><code>:missdirection</code> =&gt; direction to fill missing data (:symmetric, :reverse, :forward) </li><li><code>:dateinterval</code> =&gt; time period to use for grouping,</li><li><code>:nnsize</code> =&gt; neighborhood size,</li><li><code>:strict</code> =&gt; boolean value to indicate whether to be strict about replacement or not,</li><li>`:aggregator =&gt; function to aggregate based on date interval</li></ul><p>Example:</p><pre><code class="language-none">Random.seed!(123)
gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
gval1 = Array{Union{Missing,Float64}}(rand(length(gdate)))
gval2 = Array{Union{Missing,Float64}}(rand(length(gdate)))
gval3 = Array{Union{Missing,Float64}}(rand(length(gdate)))
gmissing = 50000
gndxmissing1 = Random.shuffle(1:length(gdate))[1:gmissing]
gndxmissing2 = Random.shuffle(1:length(gdate))[1:gmissing]
gndxmissing3 = Random.shuffle(1:length(gdate))[1:gmissing]
X = DataFrame(Date=gdate,Temperature=gval1,Humidity=gval2,Ozone=gval3)
X.Temperature[gndxmissing1] .= missing
X.Humidity[gndxmissing2] .= missing
X.Ozone[gndxmissing3] .= missing

dnnr = DateValMultiNNer(Dict(
      :type=&gt;:linear,
      :dateinterval=&gt;Dates.Hour(1),
      :nnsize=&gt;10,
      :missdirection =&gt; :symmetric,
      :strict=&gt;true,
      :aggregator =&gt; :mean))
fit!(dnnr,X)
transform!(dnnr,X)</code></pre><p>Implements: <code>fit!</code>, transform!`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L778-L829">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.DateValNNer" href="#TSML.ValDateFilters.DateValNNer"><code>TSML.ValDateFilters.DateValNNer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DateValNNer(
   Dict(
      :missdirection =&gt; :symmetric, #:reverse, # or :forward or :symmetric
      :dateinterval =&gt; Dates.Hour(1),
      :nnsize =&gt; 1,
      :strict =&gt; true,
      :aggregator =&gt; :median
  )
)</code></pre><p>Fills <code>missings</code> with their nearest-neighbors.</p><ul><li><code>:missdirection</code> =&gt; direction to fill missing data (:symmetric, :reverse, :forward) </li><li><code>:dateinterval</code> =&gt; time period to use for grouping,</li><li><code>:nnsize</code> =&gt; neighborhood size,</li><li><code>:strict</code> =&gt; boolean value to indicate whether to be strict about replacement or not,</li><li>`:aggregator =&gt; function to aggregate based on date interval</li></ul><p>Example:</p><pre><code class="language-none">Random.seed!(123)
gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
gval = Array{Union{Missing,Float64}}(rand(length(gdate)))
gmissing = 50000
gndxmissing = Random.shuffle(1:length(gdate))[1:gmissing]
X = DataFrame(Date=gdate,Value=gval)
X.Value[gndxmissing] .= missing

dnnr = DateValNNer(Dict(
      :dateinterval=&gt;Dates.Hour(1),
      :nnsize=&gt;10,
      :missdirection =&gt; :symmetric,
      :strict=&gt;true,
      :aggregator =&gt; :mean))
fit!(dnnr,X)
transform!(dnnr,X)</code></pre><p>Implements: <code>fit!</code>, transform!`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L424-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.DateValgator" href="#TSML.ValDateFilters.DateValgator"><code>TSML.ValDateFilters.DateValgator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DateValgator(args=Dict())
   Dict(
    :dateinterval =&gt; Dates.Hour(1),
    :aggregator =&gt; :median
  )
)</code></pre><p>Aggregates values based on date period specified.</p><p>Example:</p><pre><code class="language-none"># generate random values with missing data
Random.seed!(123)
gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
gval = Array{Union{Missing,Float64}}(rand(length(gdate)))
gmissing = 50000
gndxmissing = Random.shuffle(1:length(gdate))[1:gmissing]
X = DataFrame(Date=gdate,Value=gval)
X.Value[gndxmissing] .= missing

dtvlmean = DateValgator(Dict(
      :dateinterval=&gt;Dates.Hour(1),
      :aggregator =&gt; :mean))
fit!(dtvlmean,X)
res = transform!(dtvlmean,X)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L204-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.DateValizer" href="#TSML.ValDateFilters.DateValizer"><code>TSML.ValDateFilters.DateValizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DateValizer(
   Dict(
    :medians =&gt; DataFrame(),
    :dateinterval =&gt; Dates.Hour(1)
  )
)</code></pre><p>Normalizes and cleans time series by replacing <code>missings</code> with global medians  computed based on time period groupings.</p><p>Example:</p><pre><code class="language-none"># generate random values with missing data
Random.seed!(123)
gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
gval = Array{Union{Missing,Float64}}(rand(length(gdate)))
gmissing = 50000
gndxmissing = Random.shuffle(1:length(gdate))[1:gmissing]
X = DataFrame(Date=gdate,Value=gval)
X.Value[gndxmissing] .= missing

dvzr = DateValizer(Dict(:dateinterval=&gt;Dates.Hour(1)))
fit!(dvzr,X)
transform!(dvzr,X)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L298-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Dateifier" href="#TSML.ValDateFilters.Dateifier"><code>TSML.ValDateFilters.Dateifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dateifier(args=Dict())
   Dict(
    :ahead =&gt; 1,
    :size =&gt; 7,
    :stride =&gt; 1
   )
)</code></pre><p>Converts a 1-D date series into sliding window matrix for ML training</p><p>Example: </p><pre><code class="language-none">dtr = Dateifier(Dict())
lower = DateTime(2017,1,1)
upper = DateTime(2018,1,31)
dat=lower:Dates.Day(1):upper |&gt; collect
vals = rand(length(dat))
x=DataFrame(Date=dat,Value=vals)
fit!(dtr,x)
res = transform!(dtr,x)</code></pre><p>Implements: <code>&#39;fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L126-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Matrifier" href="#TSML.ValDateFilters.Matrifier"><code>TSML.ValDateFilters.Matrifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Matrifier(Dict(
   Dict(
    :ahead  =&gt; 1,
    :size   =&gt; 7,
    :stride =&gt; 1,
  )
)</code></pre><p>Converts a 1-D timeseries into sliding window matrix for ML training:</p><ul><li><code>:ahead</code>  =&gt; steps ahead to predict</li><li><code>:size</code>   =&gt; size of sliding window</li><li><code>:stride</code> =&gt; amount of overlap in sliding window</li></ul><p>Example:</p><pre><code class="language-none">mtr = Matrifier(Dict(:ahead=&gt;24,:size=&gt;24,:stride=&gt;5))
lower = DateTime(2017,1,1)
upper = DateTime(2017,1,5)
dat=lower:Dates.Hour(1):upper |&gt; collect
vals = 1:length(dat)
x = DataFrame(Date=dat,Value=vals)
fit!(mtr,x)
res = transform!(mtr,x)</code></pre><p>Implements: <code>fit!</code>, <code>transform</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L34-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(dnnr::DateValMultiNNer,xx::T,y::Vector=[]) where {T&lt;:DataFrame}</code></pre><p>Validates and checks arguments for errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L856-L860">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(dtr::Dateifier,xx::T,y::Vector=[]) where {T&lt;:Union{Matrix,Vector,DataFrame}}</code></pre><p>Computes range of dates to be used during transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L167-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(mtr::Matrifier,xx::T,y::Vector=Vector()) where {T&lt;:Union{Matrix,Vector,DataFrame}}</code></pre><p>Checks and validate inputs are in correct structure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(csvwtr::CSVDateValWriter,x::T=[],y::Vector=[]) where {T&lt;:Union{DataFrame,Vector,Matrix}}</code></pre><p>Makes sure filename and dateformat are not empty strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L686-L690">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(dnnr::DateValLinearImputer,xx::T,y::Vector=[]) where {T&lt;:DataFrame}</code></pre><p>Validates and checks arguments for errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L967-L971">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(dvmr::DateValgator,xx::T,y::Vector=[]) where {T&lt;:Union{Matrix,DataFrame}}</code></pre><p>Checks and validates arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L257-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(csvrdr::CSVDateValReader,x::T=[],y::Vector=[]) where {T&lt;:Union{DataFrame,Vector,Matrix}}</code></pre><p>Makes sure filename and dateformat are not empty strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L614-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(dnnr::DateValNNer,xx::T,y::Vector=[]) where {T&lt;:DataFrame}</code></pre><p>Validates and checks arguments for errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L484-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(dvzr::DateValizer,xx::T,y::Vector=[]) where {T&lt;:DataFrame}</code></pre><p>Validates input and computes global medians grouped by time period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L375-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!" href="#AMLPipelineBase.AbsTypes.transform!"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transform!(csvrdr::CSVDateValReader,x::T=[]) where {T&lt;:Union{DataFrame,Vector,Matrix}}</code></pre><p>Uses CSV package to read the csv file and converts it to dataframe.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L625-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{CSVDateValWriter,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{CSVDateValWriter,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(csvwtr::CSVDateValWriter,x::T) where {T&lt;:Union{DataFrame,Vector,Matrix}}</code></pre><p>Uses CSV package to write the dataframe into a csv file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L697-L701">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{DateValLinearImputer,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{DateValLinearImputer,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(dnnr::DateValLinearImputer,xx::T) where {T&lt;:DataFrame}</code></pre><p>Replaces <code>missings</code> by linear interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L977-L981">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{DateValMultiNNer,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{DateValMultiNNer,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(dnnr::DateValMultiNNer,xx::T) where {T&lt;:DataFrame}</code></pre><p>Replaces <code>missings</code> by nearest neighbor or linear interpolation by looping over the dataset  for each column until all missing values are gone.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L871-L876">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{DateValNNer,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{DateValNNer,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(dnnr::DateValNNer,xx::T) where {T&lt;:DataFrame}</code></pre><p>Replaces <code>missings</code> by nearest neighbor looping over the dataset until all missing values are gone.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L496-L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{DateValgator,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{DateValgator,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(dvmr::DateValgator,xx::T) where {T&lt;:DataFrame}</code></pre><p>Aggregates values grouped by date-time period using aggregate  function such as mean, median, maximum, minimum. Default is mean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L269-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{DateValizer,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{DateValizer,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(dvzr::DateValizer,xx::T) where {T&lt;:DataFrame}</code></pre><p>Replaces <code>missing</code> with the corresponding global medians with respect to time period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L391-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Dateifier,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Dateifier,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(dtr::Dateifier,xx::T) where {T&lt;:Union{Matrix,Vector,DataFrame}}</code></pre><p>Transforms to day of the month, day of the week, etc</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Matrifier,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Matrifier,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(mtr::Matrifier,xx::T) where {T&lt;:Union{Matrix,Vector,DataFrame}}</code></pre><p>Applies the parameters of sliding windows to create the corresponding matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/valdatefilters.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.AbstractContext" href="#TSML.ValDateFilters.Imputers.AbstractContext"><code>TSML.ValDateFilters.Imputers.AbstractContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractContext</code></pre><p>An imputation context records summary information about missing data for an imputation algorithm. All <code>AbstractContext</code>s are callable with a function, which allows us to write code like:</p><pre><code class="language-julia">context() do c
    # My imputation code using a clean context
end</code></pre><p>This do-block will pass a fresh context to your code and apply the <code>on_complete</code> function on the resulting data and context state. By default, <code>on_complete</code> will throw an <a href="lib/@ref">ImputeError</a> if we have too many missing values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/context.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.Chain" href="#TSML.ValDateFilters.Imputers.Chain"><code>TSML.ValDateFilters.Imputers.Chain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Chain &lt;: Imputor</code></pre><p>Runs multiple <code>Imputor</code>s on the same data in the order they&#39;re provided.</p><p><strong>Fields</strong></p><ul><li><code>imputors::Array{Imputor}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/imputors/chain.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.Chain-Tuple{Vararg{TSML.ValDateFilters.Imputers.Imputor,N} where N}" href="#TSML.ValDateFilters.Imputers.Chain-Tuple{Vararg{TSML.ValDateFilters.Imputers.Imputor,N} where N}"><code>TSML.ValDateFilters.Imputers.Chain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Chain(imputors::Imputor...) -&gt; Chain</code></pre><p>Creates a Chain using the <code>Imputor</code>s provided (ordering matters).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/imputors/chain.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.Context-Tuple{}" href="#TSML.ValDateFilters.Imputers.Context-Tuple{}"><code>TSML.ValDateFilters.Imputers.Context</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Context</code></pre><p>Records base information about the missing data and assume all observations are equally weighted.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>n::Int</code>: number of observations</li><li><code>count::Int</code>: number of missing values found</li><li><code>limit::Float64</code>: portion of total values allowed to be imputed (should be between 0.0 and 1.0).</li><li><code>is_missing::Function</code>: must return a Bool indicating if the value counts as missing</li><li><code>on_complete::Function</code>: a function to run when imputation is complete</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/context.jl#L105-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.DropObs" href="#TSML.ValDateFilters.Imputers.DropObs"><code>TSML.ValDateFilters.Imputers.DropObs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DropObs(; context=Context)</code></pre><p>Removes missing observations from the <code>AbstractArray</code> or <code>Tables.table</code> provided.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>context::AbstractContext=Context()</code>: A context which keeps track of missing data summary information</li></ul><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/imputors/drop.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.DropVars" href="#TSML.ValDateFilters.Imputers.DropVars"><code>TSML.ValDateFilters.Imputers.DropVars</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DropVars(; context=Context())</code></pre><p>Finds variables with too many missing values in a <code>AbstractMatrix</code> or <code>Tables.table</code> and removes them from the input data.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>context::AbstractContext</code>: A context which keeps track of missing data summary information</li></ul><p><strong>Examples</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/imputors/drop.jl#L53-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.Fill" href="#TSML.ValDateFilters.Imputers.Fill"><code>TSML.ValDateFilters.Imputers.Fill</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Fill(; value=mean, context=Context())</code></pre><p>Fills in the missing data with a specific value. The current implementation is univariate, so each variable in a table or matrix will be handled independently.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>value::Any</code>: A scalar or a function that returns a scalar if passed the data with missing data removed (e.g, <code>mean</code>)</li><li><code>context::AbstractContext</code>: A context which keeps track of missing data summary information</li></ul><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/imputors/fill.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.ImputeError" href="#TSML.ValDateFilters.Imputers.ImputeError"><code>TSML.ValDateFilters.Imputers.ImputeError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ImputeError{T} &lt;: Exception</code></pre><p>Is thrown by <code>impute</code> methods when the limit of imputable values has been exceeded.</p><p><strong>Fields</strong></p><ul><li>msg::T - the message to print.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/Imputers.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.Imputor" href="#TSML.ValDateFilters.Imputers.Imputor"><code>TSML.ValDateFilters.Imputers.Imputor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Imputor</code></pre><p>An imputor stores information about imputing values in <code>AbstractArray</code>s and <code>Tables.table</code>s. New imputation methods are expected to sutype <code>Imputor</code> and, at minimum, implement the <code>impute!(imp::&lt;MyImputor&gt;, data::AbstractVector)</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/imputors.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.Interpolate" href="#TSML.ValDateFilters.Imputers.Interpolate"><code>TSML.ValDateFilters.Imputers.Interpolate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Interpolate(; context=Context())</code></pre><p>Performs linear interpolation between the nearest values in an vector. The current implementation is univariate, so each variable in a table or matrix will be handled independently.</p><p>WARNING: Missing values at the head or tail of the array cannot be interpolated if there are no existing values on both sides. As a result, this method does not guarantee that all missing values will be imputed.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>context::AbstractContext</code>: A context which keeps track of missing data summary information</li></ul><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/imputors/interp.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.LOCF" href="#TSML.ValDateFilters.Imputers.LOCF"><code>TSML.ValDateFilters.Imputers.LOCF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LOCF(; context=Context())</code></pre><p>Last observation carried forward (LOCF) iterates forwards through the <code>data</code> and fills missing data with the last existing observation. The current implementation is univariate, so each variable in a table or matrix will be handled independently.</p><p>See also:</p><ul><li><a href="lib/@ref">NOCB</a>: Next Observation Carried Backward</li></ul><p>WARNING: missing elements at the head of the array may not be imputed if there is no existing observation to carry forward. As a result, this method does not guarantee that all missing values will be imputed.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>context::AbstractContext</code>: A context which keeps track of missing data summary information</li></ul><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/imputors/locf.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.NOCB" href="#TSML.ValDateFilters.Imputers.NOCB"><code>TSML.ValDateFilters.Imputers.NOCB</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NOCB(; context=Context())</code></pre><p>Next observation carried backward (NOCB) iterates backwards through the <code>data</code> and fills missing data with the next existing observation.</p><p>See also:</p><ul><li><a href="lib/@ref">LOCF</a>: Last Observation Carried Forward</li></ul><p>WARNING: missing elements at the tail of the array may not be imputed if there is no existing observation to carry backward. As a result, this method does not guarantee that all missing values will be imputed.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>context::AbstractContext</code>: A context which keeps track of missing data summary information</li></ul><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/imputors/nocb.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.WeightedContext-Tuple{StatsBase.AbstractWeights}" href="#TSML.ValDateFilters.Imputers.WeightedContext-Tuple{StatsBase.AbstractWeights}"><code>TSML.ValDateFilters.Imputers.WeightedContext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">WeightedContext(wv; limit=1.0, is_missing=ismissing, on_complete=complete)</code></pre><p>Records information about the missing data relative to a set of weights. This context type can be useful if some missing observation are more important than others (e.g., more recent observations in time series datasets)</p><p><strong>Arguments</strong></p><ul><li><code>wv::AbstractWeights</code>: a set of statistical weights to use when evaluating the importance of each observation. Will be accumulated during imputation.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>num::Int</code>: number of observations</li><li><code>s::Float64</code>: sum of the weights of missing values</li><li><code>limit::Float64</code>: portion of total values allowed to be imputed (should be between 0.0 and 1.0).</li><li><code>is_missing::Function</code>: returns a Bool if the value counts as missing</li><li><code>on_complete::Function</code>: a function to run when imputation is complete</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/context.jl#L164-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∘-Tuple{TSML.ValDateFilters.Imputers.Imputor,TSML.ValDateFilters.Imputers.Imputor}" href="#Base.:∘-Tuple{TSML.ValDateFilters.Imputers.Imputor,TSML.ValDateFilters.Imputers.Imputor}"><code>Base.:∘</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compose new <code>Imputor</code> chains with the composition operator</p><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/imputors/chain.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findfirst-Tuple{TSML.ValDateFilters.Imputers.AbstractContext,AbstractArray{T,1} where T}" href="#Base.findfirst-Tuple{TSML.ValDateFilters.Imputers.AbstractContext,AbstractArray{T,1} where T}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findfirst(ctx::AbstractContext, data::AbstractVector) -&gt; Int</code></pre><p>Returns the first non-missing index in <code>data</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ctx::AbstractContext</code>: the context to pass into <code>ismissing!</code></li><li><code>data::AbstractVector</code>: the data array to search</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: the first index in <code>data</code> that isn&#39;t missing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/context.jl#L49-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findlast-Tuple{TSML.ValDateFilters.Imputers.AbstractContext,AbstractArray{T,1} where T}" href="#Base.findlast-Tuple{TSML.ValDateFilters.Imputers.AbstractContext,AbstractArray{T,1} where T}"><code>Base.findlast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findlast(ctx::AbstractContext, data::AbstractVector) -&gt; Int</code></pre><p>Returns the last non-missing index in <code>data</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ctx::AbstractContext</code>: the context to pass into <code>ismissing!</code></li><li><code>data::AbstractVector</code>: the data array to search</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: the last index in <code>data</code> that isn&#39;t missing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/context.jl#L65-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findnext-Tuple{TSML.ValDateFilters.Imputers.AbstractContext,AbstractArray{T,1} where T,Int64}" href="#Base.findnext-Tuple{TSML.ValDateFilters.Imputers.AbstractContext,AbstractArray{T,1} where T,Int64}"><code>Base.findnext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findnext(ctx::AbstractContext, data::AbstractVector) -&gt; Int</code></pre><p>Returns the next non-missing index in <code>data</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ctx::AbstractContext</code>: the context to pass into <code>ismissing!</code></li><li><code>data::AbstractVector</code>: the data array to search</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: the next index in <code>data</code> that isn&#39;t missing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/context.jl#L81-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.chain!-Tuple{Any,Function,Vararg{TSML.ValDateFilters.Imputers.Imputor,N} where N}" href="#TSML.ValDateFilters.Imputers.chain!-Tuple{Any,Function,Vararg{TSML.ValDateFilters.Imputers.Imputor,N} where N}"><code>TSML.ValDateFilters.Imputers.chain!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chain!(data, missing::Function, imputors::Imputor...; kwargs...)</code></pre><p>Creates a <code>Chain</code> with <code>imputors</code> and calls <code>impute!(imputor, missing, data; kwargs...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/deprecated.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.chain!-Tuple{Any,Vararg{TSML.ValDateFilters.Imputers.Imputor,N} where N}" href="#TSML.ValDateFilters.Imputers.chain!-Tuple{Any,Vararg{TSML.ValDateFilters.Imputers.Imputor,N} where N}"><code>TSML.ValDateFilters.Imputers.chain!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chain!(data, imputors::Imputor...; kwargs...)</code></pre><p>Creates a <code>Chain</code> with <code>imputors</code> and calls <code>impute!(data, imputor)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/deprecated.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.chain-Tuple{Any,Vararg{Any,N} where N}" href="#TSML.ValDateFilters.Imputers.chain-Tuple{Any,Vararg{Any,N} where N}"><code>TSML.ValDateFilters.Imputers.chain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chain(data, args...; kwargs...)</code></pre><p>Copies the <code>data</code> before calling <code>chain!(data, args...; kwargs...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/deprecated.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.dropobs" href="#TSML.ValDateFilters.Imputers.dropobs"><code>TSML.ValDateFilters.Imputers.dropobs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Impute.dropobs(data; dims=1, context=Context())</code></pre><p>Removes missing observations from the <code>AbstractArray</code> or <code>Tables.table</code> provided. See <a href="lib/@ref">DropObs</a> for details.</p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; using DataFrames; using Impute: Impute, Context

julia&gt; df = DataFrame(:a =&gt; [1.0, 2.0, missing, missing, 5.0], :b =&gt; [1.1, 2.2, 3.3, missing, 5.5])
5×2 DataFrames.DataFrame
│ Row │ a        │ b        │
│     │ Float64⍰ │ Float64⍰ │
├─────┼──────────┼──────────┤
│ 1   │ 1.0      │ 1.1      │
│ 2   │ 2.0      │ 2.2      │
│ 3   │ missing  │ 3.3      │
│ 4   │ missing  │ missing  │
│ 5   │ 5.0      │ 5.5      │

julia&gt; Impute.dropobs(df; dims=2, context=Context(; limit=1.0))
3×2 DataFrames.DataFrame
│ Row │ a       │ b       │
│     │ Float64 │ Float64 │
├─────┼─────────┼─────────┤
│ 1   │ 1.0     │ 1.1     │
│ 2   │ 2.0     │ 2.2     │
│ 3   │ 5.0     │ 5.5     │</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/Imputers.jl#L86-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.dropvars" href="#TSML.ValDateFilters.Imputers.dropvars"><code>TSML.ValDateFilters.Imputers.dropvars</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Impute.dropvars(data; dims=1, context=Context())</code></pre><p>Finds variables with too many missing values in a <code>AbstractMatrix</code> or <code>Tables.table</code> and removes them from the input data. See <a href="lib/@ref">DropVars</a> for details.</p><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/Imputers.jl#L118-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.fill" href="#TSML.ValDateFilters.Imputers.fill"><code>TSML.ValDateFilters.Imputers.fill</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Impute.fill(data; value=mean, dims=1, context=Context())</code></pre><p>Fills in the missing data with a specific value. See <a href="lib/@ref">Fill</a> for details.</p><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/Imputers.jl#L136-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.impute!-Tuple{AbstractArray{T,2} where T,TSML.ValDateFilters.Imputers.Imputor}" href="#TSML.ValDateFilters.Imputers.impute!-Tuple{AbstractArray{T,2} where T,TSML.ValDateFilters.Imputers.Imputor}"><code>TSML.ValDateFilters.Imputers.impute!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">impute!(data::AbstractMatrix, imp::Imputor; kwargs...)</code></pre><p>Impute the data in a matrix by imputing the values one variable at a time; if this is not the desired behaviour custom imputor methods should overload this method.</p><p><strong>Arguments</strong></p><ul><li><code>data::AbstractMatrix</code>: the data to impute</li><li><code>imp::Imputor</code>: the Imputor method to use</li></ul><p><strong>Keywords</strong></p><ul><li><code>dims</code>: The dimension to impute along (e.g., observations dim)</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix</code>: the input <code>data</code> with values imputed</li></ul><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/imputors.jl#L79-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.impute!-Tuple{Any,Function,Symbol,Vararg{Any,N} where N}" href="#TSML.ValDateFilters.Imputers.impute!-Tuple{Any,Function,Symbol,Vararg{Any,N} where N}"><code>TSML.ValDateFilters.Imputers.impute!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">impute!(data, missing::Function, method::Symbol=:interp, args...; limit::Float64=0.1)</code></pre><p>Creates the appropriate <code>Imputor</code> type and <code>Context</code> (using <code>missing</code> function) in order to call <code>impute!(data, imputor::Imputor)</code> with them.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: the datset containing missing elements we should impute.</li><li><code>missing::Function</code>: the missing data function to use</li><li><code>method::Symbol</code>: the imputation method to use   (options: [<code>:drop</code>, <code>:fill</code>, <code>:interp</code>, <code>:locf</code>, <code>:nocb</code>])</li><li><code>args::Any...</code>: any arguments you should pass to the <code>Imputor</code> constructor.</li><li><code>limit::Float64</code>: missing data ratio limit/threshold (default: 0.1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/deprecated.jl#L51-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.impute!-Tuple{Any,Symbol,Vararg{Any,N} where N}" href="#TSML.ValDateFilters.Imputers.impute!-Tuple{Any,Symbol,Vararg{Any,N} where N}"><code>TSML.ValDateFilters.Imputers.impute!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">impute!(data, method::Symbol=:interp, args...; limit::Float64=0.1)</code></pre><p>Looks up the <code>Imputor</code> type for the <code>method</code>, creates it and calls <code>impute!(data, imputor::Imputor)</code> with it.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: the datset containing missing elements we should impute.</li><li><code>method::Symbol</code>: the imputation method to use   (options: [<code>:drop</code>, <code>:fill</code>, <code>:interp</code>, <code>:locf</code>, <code>:nocb</code>])</li><li><code>args::Any...</code>: any arguments you should pass to the <code>Imputor</code> constructor.</li><li><code>limit::Float64</code>: missing data ratio limit/threshold (default: 0.1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/deprecated.jl#L20-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.impute!-Tuple{Any,TSML.ValDateFilters.Imputers.Chain}" href="#TSML.ValDateFilters.Imputers.impute!-Tuple{Any,TSML.ValDateFilters.Imputers.Chain}"><code>TSML.ValDateFilters.Imputers.impute!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">impute!(data, imp::Chain)</code></pre><p>Runs the <code>Imputor</code>s on the supplied data.</p><p><strong>Arguments</strong></p><ul><li><code>imp::Chain</code>: the chain to run</li><li><code>data</code>: our data to impute</li></ul><p><strong>Returns</strong></p><ul><li>our imputed data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/imputors/chain.jl#L32-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.impute!-Tuple{Any,TSML.ValDateFilters.Imputers.Imputor}" href="#TSML.ValDateFilters.Imputers.impute!-Tuple{Any,TSML.ValDateFilters.Imputers.Imputor}"><code>TSML.ValDateFilters.Imputers.impute!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">impute!(table, imp::Imputor)</code></pre><p>Imputes the data in a table by imputing the values 1 column at a time; if this is not the desired behaviour custom imputor methods should overload this method.</p><p><strong>Arguments</strong></p><ul><li><code>imp::Imputor</code>: the Imputor method to use</li><li><code>table</code>: the data to impute</li></ul><p><strong>Returns</strong></p><ul><li>the input <code>data</code> with values imputed</li></ul><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/imputors.jl#L104-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.impute-Tuple{Any,TSML.ValDateFilters.Imputers.Imputor}" href="#TSML.ValDateFilters.Imputers.impute-Tuple{Any,TSML.ValDateFilters.Imputers.Imputor}"><code>TSML.ValDateFilters.Imputers.impute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">impute(data, imp::Imputor; kwargs...)</code></pre><p>Returns a new copy of the <code>data</code> with the missing data imputed by the imputor <code>imp</code>.</p><p><strong>Keywords</strong></p><ul><li><code>dims</code>: The dimension to impute along (e.g., observations dim)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/imputors.jl#L66-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.impute-Tuple{Any,Vararg{Any,N} where N}" href="#TSML.ValDateFilters.Imputers.impute-Tuple{Any,Vararg{Any,N} where N}"><code>TSML.ValDateFilters.Imputers.impute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">impute(data, args...; kwargs...)</code></pre><p>Copies the <code>data</code> before calling <code>impute!(new_data, args...; kwargs...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/deprecated.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.interp" href="#TSML.ValDateFilters.Imputers.interp"><code>TSML.ValDateFilters.Imputers.interp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Impute.interp(data; dims=1, context=Context())</code></pre><p>Performs linear interpolation between the nearest values in an vector. See <a href="lib/@ref">Interpolate</a> for details.</p><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/Imputers.jl#L127-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.ismissing!-Tuple{TSML.ValDateFilters.Imputers.AbstractContext,Any}" href="#TSML.ValDateFilters.Imputers.ismissing!-Tuple{TSML.ValDateFilters.Imputers.AbstractContext,Any}"><code>TSML.ValDateFilters.Imputers.ismissing!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ismissing!(ctx::AbstractContext, x) -&gt; Bool</code></pre><p>Uses <code>ctx.is_missing</code> to determine if x is missing. If x is a <code>NamedTuple</code> or an <code>AbstractArray</code> then <code>ismissing!</code> will return true if <code>ctx.is_missing</code> returns true for any element. The ctx.count is increased whenever whenever we return true and if <code>ctx.count / ctx.num</code> exceeds our <code>ctx.limit</code> we throw an <code>ImputeError</code></p><p><strong>Arguments</strong></p><ul><li><code>ctx::Context</code>: the contextual information about missing information.</li><li><code>x</code>: the value to check (may be an single values, abstract array or row)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/context.jl#L23-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.locf" href="#TSML.ValDateFilters.Imputers.locf"><code>TSML.ValDateFilters.Imputers.locf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Impute.locf(data; dims=1, context=Context())</code></pre><p>Iterates forwards through the <code>data</code> and fills missing data with the last existing observation. See <a href="lib/@ref">LOCF</a> for details.</p><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/Imputers.jl#L144-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.nocb" href="#TSML.ValDateFilters.Imputers.nocb"><code>TSML.ValDateFilters.Imputers.nocb</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Impute.nocb(data; dims=1, context=Context())</code></pre><p>Iterates backwards through the <code>data</code> and fills missing data with the next existing observation. See <a href="lib/@ref">LOCF</a> for details.</p><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/Imputers.jl#L153-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.splitkwargs-Union{Tuple{T}, Tuple{Type{T},Vararg{Any,N} where N}} where T&lt;:TSML.ValDateFilters.Imputers.Imputor" href="#TSML.ValDateFilters.Imputers.splitkwargs-Union{Tuple{T}, Tuple{Type{T},Vararg{Any,N} where N}} where T&lt;:TSML.ValDateFilters.Imputers.Imputor"><code>TSML.ValDateFilters.Imputers.splitkwargs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">splitkwargs(::Type{T}, kwargs...) where T &lt;: Imputor -&gt; (imp, rem)</code></pre><p>Takes an Imputor type with kwargs and returns the constructed imputor and the unused kwargs which should be passed to the <code>impute!</code> call.</p><p>NOTE: This is used by utility methods with construct and imputor and call impute in 1 call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/imputer/imputors.jl#L32-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Imputers.srs" href="#TSML.ValDateFilters.Imputers.srs"><code>TSML.ValDateFilters.Imputers.srs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Impute.srs(data; rng=Random.GLOBAL_RNG, context=Context())</code></pre><p>Simple Random Sampling (SRS) imputation is a method for imputing both continuous and categorical variables. Furthermore, it completes imputation while preserving the distributional properties of the variables (e.g., mean, standard deviation).</p><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/Imputers.jl#L162-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.SVMModels.SVMModel" href="#TSML.SVMModels.SVMModel"><code>TSML.SVMModels.SVMModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SVMModel(
  Dict(
    :name =&gt; &quot;svm&quot;,
    :svmtype =&gt; &quot;SVC&quot;
  )
)</code></pre><p>Wrapper for LIBSVM.jl for pipeline integration.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/svm.jl#L26-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.SVMModels.SVMModel-Tuple{String,Dict}" href="#TSML.SVMModels.SVMModel-Tuple{String,Dict}"><code>TSML.SVMModels.SVMModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SVMModel(svmt::String,opt=Dict())</code></pre><p>Helper function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/svm.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.SVMModels.SVMModel-Tuple{String}" href="#TSML.SVMModels.SVMModel-Tuple{String}"><code>TSML.SVMModels.SVMModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SVMModel(svmt::String;opt...)</code></pre><p>Helper function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/svm.jl#L73-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fit!(svm::SVMModel, features::DataFrame, labels::Vector=[])</p><p>Train the model using  SVM fit!</p><p><strong>Arguments</strong></p><ul><li><code>svm::SVMModel:</code> custom type</li><li><code>features::DataFrame</code>: input</li><li><code>labels::Vector=[]</code>: </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/svm.jl#L95-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{SVMModel,DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{SVMModel,DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(svm::SVMModel, features::DataFrame)</code></pre><p>Predict using svm model</p><p><strong>Arguments</strong></p><ul><li><code>svm::SVMModel</code>: custom type</li><li><code>features::DataFrame</code>: input</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/f53e9cdd1e118c9fc19b4e69a60b6c78a38a0de5/src/svm.jl#L118-L126">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/imputation/">« Imputation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 23 October 2020 06:03">Friday 23 October 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
